import { ChangeDetectionStrategy, Component, Inject, ViewChild, ViewChildren } from '@angular/core';
import { SortingDirection } from '../../data-operations/sorting-strategy';
import { IgxGridForOfDirective } from '../../directives/for-of/for_of.directive';
import { AbsoluteScrollStrategy, AutoPositionStrategy, VerticalAlignment } from '../../services/public_api';
import { IGX_GRID_BASE } from '../common/grid.interface';
import { IgxGridHeaderRowComponent } from '../headers/grid-header-row.component';
import { DropPosition } from '../moving/moving.service';
import { PivotUtil } from './pivot-util';
import * as i0 from "@angular/core";
import * as i1 from "../../chips/chips-area.component";
import * as i2 from "../../chips/chip.component";
import * as i3 from "../../icon/icon.component";
import * as i4 from "../../badge/badge.component";
import * as i5 from "../headers/grid-header-group.component";
import * as i6 from "../../drop-down/drop-down.component";
import * as i7 from "../../drop-down/drop-down-item.component";
import * as i8 from "../filtering/excel-style/grid.excel-style-filtering.component";
import * as i9 from "../filtering/excel-style/excel-style-search.component";
import * as i10 from "@angular/common";
import * as i11 from "../../directives/drag-drop/drag-drop.directive";
import * as i12 from "../../directives/prefix/prefix.directive";
import * as i13 from "../../directives/suffix/suffix.directive";
import * as i14 from "../../drop-down/drop-down-navigation.directive";
import * as i15 from "../../directives/for-of/for_of.directive";
import * as i16 from "../common/pipes";
import * as i17 from "../headers/pipes";
/**
 *
 * For all intents & purposes treat this component as what a <thead> usually is in the default <table> element.
 *
 * This container holds the pivot grid header elements and their behavior/interactions.
 *
 * @hidden @internal
 */
export class IgxPivotHeaderRowComponent extends IgxGridHeaderRowComponent {
    constructor(grid, ref, cdr, renderer) {
        super(ref, cdr);
        this.grid = grid;
        this.ref = ref;
        this.cdr = cdr;
        this.renderer = renderer;
        this.aggregateList = [];
        this.filterDropdownDimensions = new Set();
        this.filterAreaDimensions = new Set();
        this._dropPos = DropPosition.AfterDropTarget;
        this._subMenuPositionSettings = {
            verticalStartPoint: VerticalAlignment.Bottom,
            closeAnimation: undefined
        };
        this._subMenuOverlaySettings = {
            closeOnOutsideClick: true,
            modal: false,
            positionStrategy: new AutoPositionStrategy(this._subMenuPositionSettings),
            scrollStrategy: new AbsoluteScrollStrategy()
        };
        /**
        * @hidden
        * @internal
        * Default is a single empty level since default depth is 1
        */
        this.columnDimensionsByLevel = [[]];
    }
    get headerForOf() {
        return this.headerContainers.last;
    }
    /**
    * @hidden @internal
    */
    get isFiltersButton() {
        let chipsWidth = 0;
        this.filterDropdownDimensions.clear();
        this.filterAreaDimensions.clear();
        if (this.filterArea?.chipsList && this.filterArea.chipsList.length !== 0) {
            const styles = getComputedStyle(this.pivotFilterContainer.nativeElement);
            const containerPaddings = parseFloat(styles.paddingLeft) + parseFloat(styles.paddingRight);
            chipsWidth += containerPaddings + (this.filtersButton && this.filterArea?.chipsList.length > 1 ? this.filtersButton.el.nativeElement.getBoundingClientRect().width : 0);
            this.filterArea.chipsList.forEach(chip => {
                const dim = this.grid.filterDimensions.find(x => x.memberName === chip.id);
                if (dim) {
                    // 8 px margin between chips
                    const currentChipWidth = chip.nativeElement.getBoundingClientRect().width + 8;
                    if (chipsWidth + currentChipWidth < this.grid.pivotRowWidths) {
                        this.filterAreaDimensions.add(dim);
                    }
                    else {
                        this.filterDropdownDimensions.add(dim);
                    }
                    chipsWidth += currentChipWidth;
                }
            });
            return this.filterDropdownDimensions.size > 0;
        }
        return false;
    }
    /**
    * @hidden
    * @internal
    */
    get totalDepth() {
        const columnDimensions = this.grid.columnDimensions;
        if (columnDimensions.length === 0) {
            return 1;
        }
        let totalDepth = columnDimensions.map(x => PivotUtil.getDimensionDepth(x) + 1).reduce((acc, val) => acc + val);
        if (this.grid.hasMultipleValues) {
            totalDepth += 1;
        }
        return totalDepth;
    }
    /**
    * @hidden
    * @internal
    */
    get maxContainerHeight() {
        return this.totalDepth * this.grid.renderedRowHeight;
    }
    /**
    * @hidden
    * @internal
    */
    calcHeight(col, index) {
        return !col.columnGroup && col.level < this.totalDepth && col.level === index ? (this.totalDepth - col.level) * this.grid.rowHeight : this.grid.rowHeight;
    }
    /**
    * @hidden
    * @internal
    */
    isDuplicateOfExistingParent(col, lvl) {
        const parentCollection = lvl > 0 ? this.columnDimensionsByLevel[lvl - 1] : [];
        const duplicate = parentCollection.indexOf(col) !== -1;
        return duplicate;
    }
    /**
    * @hidden
    * @internal
    */
    isMultiRow(col, lvl) {
        const isLeaf = !col.columnGroup;
        return isLeaf && lvl !== this.totalDepth - 1;
    }
    /**
    * @hidden
    * @internal
    */
    populateColumnDimensionsByLevel() {
        const res = [];
        for (let i = 0; i < this.totalDepth; i++) {
            res[i] = [];
        }
        const cols = this.unpinnedColumnCollection;
        // populate column dimension matrix recursively
        this.populateDimensionRecursively(cols.filter(x => x.level === 0), 0, res);
        this.columnDimensionsByLevel = res;
    }
    populateDimensionRecursively(currentLevelColumns, level = 0, res) {
        currentLevelColumns.forEach(col => {
            if (res[level]) {
                res[level].push(col);
                if (col.columnGroup && col.children.length > 0) {
                    const visibleColumns = col.children.toArray().filter(x => !x.hidden);
                    this.populateDimensionRecursively(visibleColumns, level + 1, res);
                }
                else if (level < this.totalDepth - 1) {
                    for (let i = level + 1; i <= this.totalDepth - 1; i++) {
                        res[i].push(col);
                    }
                }
            }
        });
    }
    /**
    * @hidden
    * @internal
    */
    ngOnChanges(changes) {
        if (changes.unpinnedColumnCollection) {
            this.populateColumnDimensionsByLevel();
        }
    }
    /**
    * @hidden
    * @internal
    */
    onDimDragStart(event, area) {
        this.cdr.detectChanges();
        for (let chip of this.notificationChips) {
            const parent = chip.nativeElement.parentElement;
            if (area.chipsList.toArray().indexOf(chip) === -1 &&
                parent.children.length > 0 &&
                parent.children.item(0).id !== 'empty') {
                chip.nativeElement.hidden = false;
                parent.parentElement.scrollTo({ left: chip.nativeElement.offsetLeft });
            }
        }
    }
    /**
    * @hidden
    * @internal
    */
    onDimDragEnd() {
        for (let chip of this.notificationChips) {
            chip.nativeElement.hidden = true;
        }
    }
    /**
    * @hidden
    * @internal
    */
    getAreaHeight(area) {
        const chips = area.chipsList;
        return chips && chips.length > 0 ? chips.first.nativeElement.offsetHeight : 0;
    }
    /**
    * @hidden
    * @internal
    */
    rowRemoved(event) {
        const row = this.grid.pivotConfiguration.rows.find(x => x.memberName === event.owner.id);
        this.grid.toggleDimension(row);
    }
    /**
    * @hidden
    * @internal
    */
    columnRemoved(event) {
        const col = this.grid.pivotConfiguration.columns.find(x => x.memberName === event.owner.id);
        this.grid.toggleDimension(col);
    }
    /**
    * @hidden
    * @internal
    */
    valueRemoved(event) {
        const value = this.grid.pivotConfiguration.values.find(x => x.member === event.owner.id || x.displayName === event.owner.id);
        this.grid.toggleValue(value);
    }
    /**
    * @hidden
    * @internal
    */
    filterRemoved(event) {
        const filter = this.grid.pivotConfiguration.filters.find(x => x.memberName === event.owner.id);
        this.grid.toggleDimension(filter);
        if (this.filterDropdownDimensions.size > 0) {
            this.onFiltersAreaDropdownClick({ target: this.filtersButton.el.nativeElement }, undefined, false);
        }
        else {
            this.grid.filteringService.hideESF();
        }
    }
    onFiltersSelectionChanged(event) {
        this.dropdownChips.chipsList.forEach(chip => {
            if (chip.id !== event.owner.id) {
                chip.selected = false;
            }
        });
        this.onFiltersAreaDropdownClick({ target: this.filtersButton.el.nativeElement }, this.grid.filterDimensions.find(dim => dim.memberName === event.owner.id), false);
    }
    /**
    * @hidden
    * @internal
    */
    onFilteringIconPointerDown(event) {
        event.stopPropagation();
        event.preventDefault();
    }
    /**
    * @hidden
    * @internal
    */
    onFilteringIconClick(event, dimension) {
        event.stopPropagation();
        event.preventDefault();
        let dim = dimension;
        const col = this.grid.dimensionDataColumns.find(x => x.field === dim.memberName || x.field === dim.member);
        this.grid.filteringService.toggleFilterDropdown(event.target, col);
    }
    /**
    * @hidden
    * @internal
    */
    onSummaryClick(eventArgs, value, dropdown, chip) {
        this._subMenuOverlaySettings.target = eventArgs.currentTarget;
        this.updateDropDown(value, dropdown, chip);
    }
    /**
     * @hidden @internal
     */
    onFiltersAreaDropdownClick(event, dimension, shouldReattach = true) {
        let dim = dimension || this.filterDropdownDimensions.values().next().value;
        const col = this.grid.dimensionDataColumns.find(x => x.field === dim.memberName || x.field === dim.member);
        if (shouldReattach) {
            this.dropdownChips.chipsList.forEach(chip => {
                chip.selected = false;
            });
            this.dropdownChips.chipsList.first.selected = true;
        }
        this.grid.filteringService.toggleFiltersESF(this.esf, event.target, col, shouldReattach);
    }
    /**
    * @hidden
    * @internal
    */
    onAggregationChange(event) {
        if (!this.isSelected(event.newSelection.value)) {
            this.value.aggregate = event.newSelection.value;
            this.grid.pipeTrigger++;
        }
    }
    /**
    * @hidden
    * @internal
    */
    isSelected(val) {
        return this.value.aggregate.key === val.key;
    }
    /**
    * @hidden
    * @internal
    */
    onChipSort(_event, dimension) {
        const startDirection = dimension.sortDirection || SortingDirection.None;
        const direction = startDirection + 1 > SortingDirection.Desc ?
            SortingDirection.None : startDirection + 1;
        this.grid.sortDimension(dimension, direction);
    }
    /**
    * @hidden
    * @internal
    */
    onDimDragOver(event, dimension) {
        if (!event.dragChip || !event.dragChip.data?.pivotArea)
            return;
        const typeMismatch = dimension !== undefined ? this.grid.pivotConfiguration.values.find(x => x.member === event.dragChip.id
            || x.displayName === event.dragChip.id) :
            !this.grid.pivotConfiguration.values.find(x => x.member === event.dragChip.id || x.displayName === event.dragChip.id);
        if (typeMismatch) {
            // cannot drag between dimensions and value
            return;
        }
        // if we are in the left half of the chip, drop on the left
        // else drop on the right of the chip
        const clientRect = event.owner.nativeElement.getBoundingClientRect();
        const pos = clientRect.width / 2;
        this._dropPos = event.originalEvent.offsetX > pos ? DropPosition.AfterDropTarget : DropPosition.BeforeDropTarget;
        if (this._dropPos === DropPosition.AfterDropTarget) {
            event.owner.nativeElement.previousElementSibling.style.visibility = 'hidden';
            event.owner.nativeElement.nextElementSibling.style.visibility = '';
        }
        else {
            event.owner.nativeElement.nextElementSibling.style.visibility = 'hidden';
            event.owner.nativeElement.previousElementSibling.style.visibility = '';
        }
    }
    /**
    * @hidden
    * @internal
    */
    onDimDragLeave(event) {
        event.owner.nativeElement.previousElementSibling.style.visibility = 'hidden';
        event.owner.nativeElement.nextElementSibling.style.visibility = 'hidden';
        this._dropPos = DropPosition.AfterDropTarget;
    }
    /**
    * @hidden
    * @internal
    */
    onAreaDragLeave(event, area) {
        const dataChips = area.chipsList.toArray().filter(x => this.notificationChips.toArray().indexOf(x) === -1);
        dataChips.forEach(element => {
            if (element.nativeElement.previousElementSibling) {
                element.nativeElement.previousElementSibling.style.visibility = 'hidden';
            }
            if (element.nativeElement.nextElementSibling) {
                element.nativeElement.nextElementSibling.style.visibility = 'hidden';
            }
        });
    }
    /**
    * @hidden
    * @internal
    */
    onValueDrop(event, area) {
        if (!(event.dragChip && event.dragChip.data?.pivotArea) && !(event.dragData?.chip && !!event.dragData.chip.data.pivotArea))
            return;
        //values can only be reordered
        const values = this.grid.pivotConfiguration.values;
        const dragId = event.dragChip?.id || event.dragData?.chip.id;
        const chipsArray = area.chipsList.toArray();
        let chipIndex = chipsArray.indexOf(event.owner) !== -1 ? chipsArray.indexOf(event.owner) : chipsArray.length;
        chipIndex = this._dropPos === DropPosition.AfterDropTarget ? chipIndex + 1 : chipIndex;
        const value = values.find(x => x.member === dragId || x.displayName === dragId);
        if (value) {
            const dragChipIndex = chipsArray.indexOf(event.dragChip || event.dragData.chip);
            this.grid.moveValue(value, dragChipIndex >= chipIndex ? chipIndex : chipIndex - 1);
        }
    }
    /**
    * @hidden
    * @internal
    */
    onDimDrop(event, area, dimensionType) {
        if (!(event.dragChip && event.dragChip.data?.pivotArea) && !(event.dragData?.chip && !!event.dragData.chip.data.pivotArea))
            return;
        const dragId = event.dragChip?.id || event.dragData?.chip.id;
        const currentDim = this.grid.getDimensionsByType(dimensionType);
        const chipsArray = area.chipsList.toArray();
        const chip = chipsArray.find(x => x.id === dragId);
        const isNewChip = chip === undefined;
        const isReorder = event.owner.id !== undefined;
        //const chipIndex = chipsArray.indexOf(event.owner) !== -1 ? chipsArray.indexOf(event.owner) : chipsArray.length;
        const chipIndex = currentDim.findIndex(x => x.memberName === event.owner.id) !== -1 ?
            currentDim.findIndex(x => x.memberName === event.owner.id) : currentDim.length;
        const targetIndex = this._dropPos === DropPosition.AfterDropTarget ? chipIndex + 1 : chipIndex;
        if (isNewChip) {
            // chip moved from an external collection
            const dim = this.grid.allDimensions.find(x => x && x.memberName === dragId);
            if (!dim) {
                // you have dragged something that is not a dimension
                return;
            }
            this.grid.moveDimension(dim, dimensionType, targetIndex);
        }
        else if (isReorder) {
            // chip from same collection, reordered.
            const newDim = currentDim.find(x => x.memberName === dragId);
            const dragChipIndex = currentDim.findIndex(x => x.memberName === dragId);
            this.grid.moveDimension(newDim, dimensionType, dragChipIndex > chipIndex ? targetIndex : targetIndex - 1);
        }
        this.grid.pipeTrigger++;
        this.grid.dimensionsChange.emit({ dimensions: currentDim, dimensionCollectionType: dimensionType });
        // clean states
        this.onDimDragEnd();
        this.onAreaDragLeave(event, area);
    }
    updateDropDown(value, dropdown, chip) {
        this.value = value;
        dropdown.width = chip.nativeElement.clientWidth + 'px';
        this.aggregateList = PivotUtil.getAggregateList(value, this.grid);
        this.cdr.detectChanges();
        dropdown.open(this._subMenuOverlaySettings);
    }
}
IgxPivotHeaderRowComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.2.2", ngImport: i0, type: IgxPivotHeaderRowComponent, deps: [{ token: IGX_GRID_BASE }, { token: i0.ElementRef }, { token: i0.ChangeDetectorRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });
IgxPivotHeaderRowComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.2.2", type: IgxPivotHeaderRowComponent, selector: "igx-pivot-header-row", viewQueries: [{ propertyName: "esf", first: true, predicate: ["esf"], descendants: true }, { propertyName: "filterArea", first: true, predicate: ["filterAreaHidden"], descendants: true }, { propertyName: "filtersButton", first: true, predicate: ["filterIcon"], descendants: true }, { propertyName: "dropdownChips", first: true, predicate: ["dropdownChips"], descendants: true }, { propertyName: "pivotFilterContainer", first: true, predicate: ["pivotFilterContainer"], descendants: true }, { propertyName: "notificationChips", predicate: ["notifyChip"], descendants: true }, { propertyName: "headerContainers", predicate: ["headerVirtualContainer"], descendants: true, read: IgxGridForOfDirective }], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: "<div>\n    <div class=\"igx-grid-thead__wrapper igx-grid-thead__wrapper--pivot\" role=\"row\" [style.width.px]=\"width\">\n        <div class=\"igx-grid__tr\" role=\"row\" [style.width.px]=\"width\">\n            <div class='igx-grid__tr-pivot--filter-container'>\n                <div #pivotFilterContainer *ngIf=\"grid.showPivotConfigurationUI\"\n                     class=\"igx-grid__tr-pivot igx-grid__tr-pivot--filter\" [style.min-width.px]=\"grid.pivotRowWidths - 1\"\n                     [style.max-width.px]=\"grid.pivotRowWidths - 1\" (igxDragLeave)=\"onAreaDragLeave($event, filterArea)\"\n                     igxDrop (dropped)=\"onDimDrop($event, filterArea, 2)\" (pointerdown)=\"$event.preventDefault()\">\n                    <!-- Filter area -->\n                    <igx-chips-area #filterArea droppable='true'>\n                    <span id='empty' igxDrop (dropped)=\"onDimDrop($event, filterArea, 2)\"\n                          *ngIf=\"grid.filterDimensions.length === 0\"\n                          class='igx-grid__pivot-empty-chip-area'>{{grid.resourceStrings.igx_grid_pivot_empty_filter_drop_area}}</span>\n                        <ng-container *ngFor=\"let filter of this.filterAreaDimensions; let last = last;\">\n                        <span [style.visibility]='\"hidden\"' class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                              [style.height.px]='getAreaHeight(filterArea)'></span>\n                            <igx-chip [id]=\"filter.memberName\" [draggable]=\"true\" [displayDensity]=\"grid.displayDensity\" [data]=\"{ pivotArea: 'filter' }\"\n                                      [removable]=\"true\" (remove)=\"filterRemoved($event)\" (dragOver)=\"onDimDragOver($event, 2)\"\n                                      (dragLeave)=\"onDimDragLeave($event)\" (dragDrop)=\"onDimDrop($event, filterArea, 2)\"\n                                      (moveStart)='onDimDragStart($event, filterArea)' (moveEnd)='onDimDragEnd()'>\n                                <igx-icon igxPrefix (pointerdown)='onFilteringIconPointerDown($event)'\n                                          (click)='onFilteringIconClick($event, filter)'>filter_list</igx-icon>\n                                {{filter.memberName}}\n                            </igx-chip>\n                            <ng-container *ngIf='last'>\n                            <span [style.visibility]='\"hidden\"' class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                                  [style.height.px]='getAreaHeight(filterArea)'></span>\n                            </ng-container>\n                        </ng-container>\n                        <igx-chip igxDrop (dragDrop)=\"onDimDrop($event, filterArea, 2)\" #notifyChip [hidden]='true'\n                                  [displayDensity]=\"grid.displayDensity\">\n                            {{grid.resourceStrings.igx_grid_pivot_filter_drop_chip}}\n                        </igx-chip>\n                    </igx-chips-area>\n                    <div class=\"igx-grid__pivot-filter-toggle\" *ngIf=\"isFiltersButton && grid.filterDimensions.length !== 0\">\n                        <igx-icon #filterIcon (pointerdown)='onFilteringIconPointerDown($event)' (click)='onFiltersAreaDropdownClick($event)'>filter_list</igx-icon>\n                        <igx-badge value=\"{{this.filterDropdownDimensions.size}}\"></igx-badge>\n                    </div>\n                </div>\n                <div class='igx-grid__tr-pivot--drop-row-area' (igxDragLeave)=\"onAreaDragLeave($event, rowArea)\" igxDrop\n                     (dropped)=\"onDimDrop($event, rowArea, 0)\">\n                </div>\n            </div>\n\n            <div class=\"igx-grid__tr-pivot-group\">\n                <div #pivotColumnContainer *ngIf=\"grid.showPivotConfigurationUI\" class=\"igx-grid__tr-pivot\"\n                     (dropped)=\"onDimDrop($event, colArea, 1)\" igxDrop (igxDragLeave)=\"onAreaDragLeave($event, colArea)\">\n                    <!-- Columns area -->\n                    <igx-chips-area #colArea droppable='true'>\n                    <span id='empty' (dropped)=\"onDimDrop($event, colArea, 1)\" igxDrop\n                        *ngIf=\"grid.columnDimensions.length === 0\" class='igx-grid__pivot-empty-chip-area'>\n                        {{grid.resourceStrings.igx_grid_pivot_empty_column_drop_area}}</span>\n                        <ng-container *ngFor=\"let col of grid.columnDimensions; let last = last;\">\n                        <span [style.visibility]='\"hidden\"' class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                              [style.height.px]='getAreaHeight(colArea)'></span>\n                            <igx-chip [draggable]=\"true\" [id]=\"col.memberName\" [displayDensity]=\"grid.displayDensity\" [data]=\"{ pivotArea: 'column' }\"\n                                      [removable]=\"true\" (remove)=\"columnRemoved($event)\" (dragOver)=\"onDimDragOver($event, 1)\"\n                                      (dragLeave)=\"onDimDragLeave($event)\" (dragDrop)=\"onDimDrop($event, colArea, 1)\"\n                                      (moveStart)='onDimDragStart($event, colArea)' (moveEnd)='onDimDragEnd()'\n                                      (click)=\"onChipSort($event, col)\">\n                                <igx-icon igxPrefix>view_column</igx-icon>\n                                <igx-icon igxPrefix (pointerdown)='onFilteringIconPointerDown($event)'\n                                          (click)='onFilteringIconClick($event, col)'>filter_list</igx-icon>\n                                {{col.memberName}}\n                                <igx-icon *ngIf=\"col.sortDirection\" igxSuffix> {{ col.sortDirection < 2 ? 'arrow_upward'\n                                    : 'arrow_downward' }}</igx-icon>\n                            </igx-chip>\n                            <ng-container *ngIf='last'>\n                            <span [style.visibility]='\"hidden\"' class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                                  [style.height.px]='getAreaHeight(colArea)'></span>\n                            </ng-container>\n                        </ng-container>\n                        <igx-chip igxDrop (dragDrop)=\"onDimDrop($event, colArea, 1)\" #notifyChip [hidden]='true'\n                                  [displayDensity]=\"grid.displayDensity\">\n                            {{grid.resourceStrings.igx_grid_pivot_column_drop_chip}}\n                        </igx-chip>\n                    </igx-chips-area>\n                </div>\n\n                <div #pivotValueContainer *ngIf=\"grid.showPivotConfigurationUI\" class=\"igx-grid__tr-pivot\"\n                     (pointerdown)=\"$event.preventDefault()\" (dropped)=\"onValueDrop($event, valueArea)\" igxDrop\n                     (igxDragLeave)=\"onAreaDragLeave($event, valueArea)\">\n                    <!-- Value area -->\n                    <igx-chips-area #valueArea droppable='true'>\n                    <span id='empty' (dropped)=\"onValueDrop($event, valueArea)\" igxDrop *ngIf=\"grid.values.length === 0\"\n                        class='igx-grid__pivot-empty-chip-area'>{{grid.resourceStrings.igx_grid_pivot_empty_value_drop_area}}</span>\n                    <ng-container *ngFor=\"let value of grid.values; let last = last;\">\n                        <span [style.visibility]='\"hidden\"' class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                              [style.height.px]='getAreaHeight(valueArea)'></span>\n                            <igx-chip #currChip [draggable]=\"true\" [id]=\"value.displayName || value.member\" [data]=\"{ pivotArea: 'value' }\"\n                                      [displayDensity]=\"grid.displayDensity\" [removable]=\"true\" (remove)=\"valueRemoved($event)\"\n                                      (dragLeave)=\"onDimDragLeave($event)\" (dragOver)=\"onDimDragOver($event)\"\n                                      (dragDrop)=\"onValueDrop($event, valueArea)\">\n                                <div class=\"igx-grid__tr-pivot-toggle-icons\" igxPrefix\n                                     (click)='onSummaryClick($event, value, dropdown, currChip)'\n                                     (pointerdown)='$event.stopPropagation()' [igxDropDownItemNavigation]=\"dropdown\">\n                                    <igx-icon>functions</igx-icon>\n                                    <igx-icon>arrow_drop_down</igx-icon>\n                                </div>\n                                {{value.aggregate.key}}({{value.displayName || value.member}})\n                            </igx-chip>\n                            <ng-container *ngIf='last'>\n                            <span [style.visibility]='\"hidden\"' class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                                  [style.height.px]='getAreaHeight(valueArea)'></span>\n                            </ng-container>\n                        </ng-container>\n                        <igx-chip igxDrop (dragDrop)=\"onValueDrop($event, valueArea)\" #notifyValueChip [hidden]='true'\n                                  [displayDensity]=\"grid.displayDensity\">\n                            {{grid.resourceStrings.igx_grid_pivot_value_drop_chip}}\n                        </igx-chip>\n                    </igx-chips-area>\n                </div>\n            </div>\n        </div>\n    </div>\n    <div role=\"rowgroup\" class=\"igx-grid-thead__wrapper\" [style.width.px]=\"width\"\n         [attr.aria-activedescendant]=\"activeDescendant\" [class.igx-grid__tr--mrl]=\"hasMRL\">\n\n        <!-- Column headers area -->\n        <div class=\"igx-grid__tr\" role=\"row\" [style.width.px]=\"width\">\n            <div #pivotContainer class=\"igx-grid__tr-pivot igx-grid__tr-pivot--row-area\"\n                 [style.width.px]=\"grid.pivotRowWidths - 1\" (igxDragLeave)=\"onAreaDragLeave($event, rowArea)\" igxDrop\n                 (dropped)=\"onDimDrop($event, rowArea, 0)\" (pointerdown)=\"$event.preventDefault()\">\n                <!-- Row area -->\n                <igx-chips-area #rowArea droppable='true'>\n                    <ng-container *ngIf=\"grid.showPivotConfigurationUI\">\n                    <span id='empty' igxDrop (dropped)=\"onDimDrop($event, rowArea, 0)\"\n                        *ngIf=\"grid.rowDimensions.length === 0 && grid.showPivotConfigurationUI\"\n                        class='igx-grid__pivot-empty-chip-area'>{{grid.resourceStrings.igx_grid_pivot_empty_row_drop_area}}</span>\n                    <ng-container *ngFor=\"let row of grid.rowDimensions; let last = last;\">\n                        <span [style.visibility]='\"hidden\"' class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                              [style.height.px]='getAreaHeight(rowArea)'></span>\n                            <igx-chip [draggable]=\"true\" [id]=\"row.memberName\" [displayDensity]=\"grid.displayDensity\" [data]=\"{ pivotArea: 'row' }\"\n                                      [removable]=\"true\" (remove)=\"rowRemoved($event)\" (dragLeave)=\"onDimDragLeave($event)\"\n                                      (dragDrop)=\"onDimDrop($event, rowArea, 0)\" (dragOver)=\"onDimDragOver($event, 0)\"\n                                      (moveStart)='onDimDragStart($event, rowArea)' (moveEnd)='onDimDragEnd()'\n                                      (click)=\"onChipSort($event, row)\">\n                                <igx-icon igxPrefix>table_rows</igx-icon>\n                                <igx-icon igxPrefix (pointerdown)='onFilteringIconPointerDown($event)'\n                                          (click)='onFilteringIconClick($event, row)'>filter_list</igx-icon>\n                                {{ row.memberName}}\n                                <igx-icon *ngIf=\"row.sortDirection\" igxSuffix> {{ row.sortDirection < 2 ? 'arrow_upward'\n                                    : 'arrow_downward' }}</igx-icon>\n                            </igx-chip>\n                            <ng-container *ngIf='last'>\n                            <span [style.visibility]='\"hidden\"' class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                                  [style.height.px]='getAreaHeight(rowArea)'></span>\n                            </ng-container>\n                        </ng-container>\n                        <igx-chip igxDrop (dragDrop)=\"onDimDrop($event, rowArea, 0)\" #notifyChip [hidden]='true'\n                                  [displayDensity]=\"grid.displayDensity\">\n                            {{grid.resourceStrings.igx_grid_pivot_row_drop_chip}}\n                        </igx-chip>\n                    </ng-container>\n                </igx-chips-area>\n            </div>\n\n            <!-- Pinned columns collection from the start -->\n            <ng-container *ngIf=\"pinnedColumnCollection.length && grid.isPinningToStart\">\n                <ng-container *ngFor=\"let column of pinnedColumnCollection | igxTopLevel\">\n                    <igx-grid-header-group [ngClass]=\"column.headerGroupClasses\"\n                                           [ngStyle]=\"column.headerGroupStyles | igxHeaderGroupStyle:column:grid.pipeTrigger\" [column]=\"column\"\n                                           [style.min-width]=\"column.calcWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                           [style.flex-basis]=\"column.calcWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                           (pointerdown)=\"grid.navigation.focusOutRowHeader($event)\">\n                    </igx-grid-header-group>\n                </ng-container>\n            </ng-container>\n            <div class=\"igx-grid-thead--virtualizationWrapper\" [style.max-height.px]='maxContainerHeight'>\n                <div class=\"igx-grid-thead__group igx-grid-thead--virtualizationContainer\" [style.height.px]='totalDepth > 1 ? grid.rowHeight : undefined' *ngFor='let dimLevelColumns of columnDimensionsByLevel; let i = index' [style.width.px]='grid.unpinnedWidth'>\n                    <ng-template igxGridFor #headerVirtualContainer let-column\n                                 [igxGridForOf]=\"dimLevelColumns\" [igxGridForOfUniqueSizeCache] = 'true' [igxForScrollContainer]=\"grid.parentVirtDir\"\n                                 [igxForContainerSize]=\"grid.unpinnedWidth\" [igxForTrackBy]=\"grid.trackColumnChanges\"\n                                 [igxForSizePropName]=\"'calcPixelWidth'\" [igxForScrollOrientation]=\"'horizontal'\">\n                        <igx-grid-header-group [ngClass]=\"column.headerGroupClasses\"\n                                               [style.height.px]='totalDepth > 1 ? calcHeight(column, i) : undefined'\n                                               [ngStyle]=\"column.headerGroupStyles |igxHeaderGroupStyle:column:grid.pipeTrigger\" [column]=\"column\"\n                                               [style.min-width]=\"column.calcWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                               [style.flex-basis]=\"column.calcWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                               [class.igx-grid__tr-pivot--columnDimensionLeaf] = 'isDuplicateOfExistingParent(column, i)'\n                                               [class.igx-grid__tr-pivot--columnMultiRowSpan] = 'isMultiRow(column, i)'\n                        >\n                        </igx-grid-header-group>\n                    </ng-template>\n                </div>\n            </div>\n\n            <!-- Pinned columns collection at the end -->\n            <ng-container *ngIf=\"pinnedColumnCollection.length && !grid.isPinningToStart\">\n                <ng-container *ngFor=\"let column of pinnedColumnCollection | igxTopLevel\">\n                    <igx-grid-header-group [ngClass]=\"column.headerGroupClasses\"\n                                           [ngStyle]=\"column.headerGroupStyles |igxHeaderGroupStyle:column:grid.pipeTrigger\" [column]=\"column\"\n                                           [style.min-width]=\"column.calcWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                           [style.flex-basis]=\"column.calcWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                           [style.left]=\"column.rightPinnedOffset\" (pointerdown)=\"grid.navigation.focusOutRowHeader($event)\">\n                    </igx-grid-header-group>\n                </ng-container>\n            </ng-container>\n        </div>\n    </div>\n</div>\n<!-- Header thumb area -->\n<div class=\"igx-grid-thead__thumb\" [hidden]=\"!grid.hasVerticalScroll()\" [style.width.px]=\"grid.scrollSize\">\n</div>\n\n<igx-drop-down #dropdown (selectionChanging)='onAggregationChange($event)'>\n    <igx-drop-down-item *ngFor=\"let item of aggregateList\" [selected]='isSelected(item)' [value]='item'>\n        {{ item.label }}\n    </igx-drop-down-item>\n</igx-drop-down>\n\n<div [hidden]='true'>\n    <igx-grid-excel-style-filtering [maxHeight]='grid.excelStyleFilterMaxHeight' [minHeight]='grid.excelStyleFilterMinHeight' #esf>\n        <div igxExcelStyleColumnOperations>\n            <igx-chips-area #dropdownChips>\n                <igx-chip *ngFor=\"let filter of this.filterDropdownDimensions\" [id]=\"filter.memberName\"\n                [displayDensity]=\"grid.displayDensity\" [removable]=\"true\" (remove)=\"filterRemoved($event)\"\n                (chipClick)='onFiltersSelectionChanged($event)' [selectable]='true' [selected]='filter === this.filterDropdownDimensions.values().next().value'>\n                {{filter.memberName}}\n            </igx-chip>\n        </igx-chips-area>\n        </div>\n        <igx-excel-style-filter-operations>\n            <igx-excel-style-search></igx-excel-style-search>\n        </igx-excel-style-filter-operations>\n    </igx-grid-excel-style-filtering>\n</div>\n\n<div style=\"visibility: hidden; position: absolute; top: -10000px\">\n    <igx-chips-area #filterAreaHidden droppable='true'>\n        <igx-chip *ngFor=\"let filter of grid.filterDimensions\" [id]=\"filter.memberName\" [draggable]=\"true\"\n            [displayDensity]=\"grid.displayDensity\" [removable]=\"true\" (remove)=\"filterRemoved($event)\">\n            <igx-icon igxPrefix>filter_list</igx-icon>\n            {{filter.memberName}}\n        </igx-chip>\n    </igx-chips-area>\n</div>\n", components: [{ type: i1.IgxChipsAreaComponent, selector: "igx-chips-area", inputs: ["class", "width", "height"], outputs: ["reorder", "selectionChange", "moveStart", "moveEnd"] }, { type: i2.IgxChipComponent, selector: "igx-chip", inputs: ["id", "tabIndex", "data", "draggable", "animateOnRelease", "hideBaseOnDrag", "removable", "removeIcon", "selectable", "selectIcon", "class", "disabled", "selected", "color", "resourceStrings"], outputs: ["selectedChange", "moveStart", "moveEnd", "remove", "chipClick", "selectedChanging", "selectedChanged", "keyDown", "dragEnter", "dragLeave", "dragOver", "dragDrop"] }, { type: i3.IgxIconComponent, selector: "igx-icon", inputs: ["family", "active", "name"] }, { type: i4.IgxBadgeComponent, selector: "igx-badge", inputs: ["id", "type", "value", "icon"] }, { type: i5.IgxGridHeaderGroupComponent, selector: "igx-grid-header-group", inputs: ["column"] }, { type: i6.IgxDropDownComponent, selector: "igx-drop-down", inputs: ["allowItemsFocus"], outputs: ["opening", "opened", "closing", "closed"] }, { type: i7.IgxDropDownItemComponent, selector: "igx-drop-down-item" }, { type: i8.IgxGridExcelStyleFilteringComponent, selector: "igx-grid-excel-style-filtering", inputs: ["column", "minHeight", "maxHeight"], outputs: ["loadingStart", "loadingEnd", "initialized", "sortingChanged", "columnChange", "listDataLoaded"] }, { type: i9.IgxExcelStyleSearchComponent, selector: "igx-excel-style-search" }], directives: [{ type: i10.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i11.IgxDropDirective, selector: "[igxDrop]", inputs: ["igxDrop", "dropChannel", "dropStrategy"], outputs: ["enter", "over", "leave", "dropped"], exportAs: ["drop"] }, { type: i10.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i12.IgxPrefixDirective, selector: "igx-prefix,[igxPrefix]" }, { type: i13.IgxSuffixDirective, selector: "igx-suffix,[igxSuffix]" }, { type: i14.IgxDropDownItemNavigationDirective, selector: "[igxDropDownItemNavigation]", inputs: ["igxDropDownItemNavigation"] }, { type: i10.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i10.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { type: i15.IgxGridForOfDirective, selector: "[igxGridFor][igxGridForOf]", inputs: ["igxGridForOf", "igxGridForOfUniqueSizeCache", "igxGridForOfVariableSizes"], outputs: ["dataChanging"] }, { type: i8.IgxExcelStyleColumnOperationsTemplateDirective, selector: "igx-excel-style-column-operations,[igxExcelStyleColumnOperations]" }, { type: i8.IgxExcelStyleFilterOperationsTemplateDirective, selector: "igx-excel-style-filter-operations,[igxExcelStyleFilterOperations]" }], pipes: { "igxTopLevel": i16.IgxGridTopLevelColumns, "igxHeaderGroupStyle": i17.IgxHeaderGroupStylePipe, "igxHeaderGroupWidth": i17.IgxHeaderGroupWidthPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.2.2", ngImport: i0, type: IgxPivotHeaderRowComponent, decorators: [{
            type: Component,
            args: [{ changeDetection: ChangeDetectionStrategy.OnPush, selector: 'igx-pivot-header-row', template: "<div>\n    <div class=\"igx-grid-thead__wrapper igx-grid-thead__wrapper--pivot\" role=\"row\" [style.width.px]=\"width\">\n        <div class=\"igx-grid__tr\" role=\"row\" [style.width.px]=\"width\">\n            <div class='igx-grid__tr-pivot--filter-container'>\n                <div #pivotFilterContainer *ngIf=\"grid.showPivotConfigurationUI\"\n                     class=\"igx-grid__tr-pivot igx-grid__tr-pivot--filter\" [style.min-width.px]=\"grid.pivotRowWidths - 1\"\n                     [style.max-width.px]=\"grid.pivotRowWidths - 1\" (igxDragLeave)=\"onAreaDragLeave($event, filterArea)\"\n                     igxDrop (dropped)=\"onDimDrop($event, filterArea, 2)\" (pointerdown)=\"$event.preventDefault()\">\n                    <!-- Filter area -->\n                    <igx-chips-area #filterArea droppable='true'>\n                    <span id='empty' igxDrop (dropped)=\"onDimDrop($event, filterArea, 2)\"\n                          *ngIf=\"grid.filterDimensions.length === 0\"\n                          class='igx-grid__pivot-empty-chip-area'>{{grid.resourceStrings.igx_grid_pivot_empty_filter_drop_area}}</span>\n                        <ng-container *ngFor=\"let filter of this.filterAreaDimensions; let last = last;\">\n                        <span [style.visibility]='\"hidden\"' class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                              [style.height.px]='getAreaHeight(filterArea)'></span>\n                            <igx-chip [id]=\"filter.memberName\" [draggable]=\"true\" [displayDensity]=\"grid.displayDensity\" [data]=\"{ pivotArea: 'filter' }\"\n                                      [removable]=\"true\" (remove)=\"filterRemoved($event)\" (dragOver)=\"onDimDragOver($event, 2)\"\n                                      (dragLeave)=\"onDimDragLeave($event)\" (dragDrop)=\"onDimDrop($event, filterArea, 2)\"\n                                      (moveStart)='onDimDragStart($event, filterArea)' (moveEnd)='onDimDragEnd()'>\n                                <igx-icon igxPrefix (pointerdown)='onFilteringIconPointerDown($event)'\n                                          (click)='onFilteringIconClick($event, filter)'>filter_list</igx-icon>\n                                {{filter.memberName}}\n                            </igx-chip>\n                            <ng-container *ngIf='last'>\n                            <span [style.visibility]='\"hidden\"' class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                                  [style.height.px]='getAreaHeight(filterArea)'></span>\n                            </ng-container>\n                        </ng-container>\n                        <igx-chip igxDrop (dragDrop)=\"onDimDrop($event, filterArea, 2)\" #notifyChip [hidden]='true'\n                                  [displayDensity]=\"grid.displayDensity\">\n                            {{grid.resourceStrings.igx_grid_pivot_filter_drop_chip}}\n                        </igx-chip>\n                    </igx-chips-area>\n                    <div class=\"igx-grid__pivot-filter-toggle\" *ngIf=\"isFiltersButton && grid.filterDimensions.length !== 0\">\n                        <igx-icon #filterIcon (pointerdown)='onFilteringIconPointerDown($event)' (click)='onFiltersAreaDropdownClick($event)'>filter_list</igx-icon>\n                        <igx-badge value=\"{{this.filterDropdownDimensions.size}}\"></igx-badge>\n                    </div>\n                </div>\n                <div class='igx-grid__tr-pivot--drop-row-area' (igxDragLeave)=\"onAreaDragLeave($event, rowArea)\" igxDrop\n                     (dropped)=\"onDimDrop($event, rowArea, 0)\">\n                </div>\n            </div>\n\n            <div class=\"igx-grid__tr-pivot-group\">\n                <div #pivotColumnContainer *ngIf=\"grid.showPivotConfigurationUI\" class=\"igx-grid__tr-pivot\"\n                     (dropped)=\"onDimDrop($event, colArea, 1)\" igxDrop (igxDragLeave)=\"onAreaDragLeave($event, colArea)\">\n                    <!-- Columns area -->\n                    <igx-chips-area #colArea droppable='true'>\n                    <span id='empty' (dropped)=\"onDimDrop($event, colArea, 1)\" igxDrop\n                        *ngIf=\"grid.columnDimensions.length === 0\" class='igx-grid__pivot-empty-chip-area'>\n                        {{grid.resourceStrings.igx_grid_pivot_empty_column_drop_area}}</span>\n                        <ng-container *ngFor=\"let col of grid.columnDimensions; let last = last;\">\n                        <span [style.visibility]='\"hidden\"' class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                              [style.height.px]='getAreaHeight(colArea)'></span>\n                            <igx-chip [draggable]=\"true\" [id]=\"col.memberName\" [displayDensity]=\"grid.displayDensity\" [data]=\"{ pivotArea: 'column' }\"\n                                      [removable]=\"true\" (remove)=\"columnRemoved($event)\" (dragOver)=\"onDimDragOver($event, 1)\"\n                                      (dragLeave)=\"onDimDragLeave($event)\" (dragDrop)=\"onDimDrop($event, colArea, 1)\"\n                                      (moveStart)='onDimDragStart($event, colArea)' (moveEnd)='onDimDragEnd()'\n                                      (click)=\"onChipSort($event, col)\">\n                                <igx-icon igxPrefix>view_column</igx-icon>\n                                <igx-icon igxPrefix (pointerdown)='onFilteringIconPointerDown($event)'\n                                          (click)='onFilteringIconClick($event, col)'>filter_list</igx-icon>\n                                {{col.memberName}}\n                                <igx-icon *ngIf=\"col.sortDirection\" igxSuffix> {{ col.sortDirection < 2 ? 'arrow_upward'\n                                    : 'arrow_downward' }}</igx-icon>\n                            </igx-chip>\n                            <ng-container *ngIf='last'>\n                            <span [style.visibility]='\"hidden\"' class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                                  [style.height.px]='getAreaHeight(colArea)'></span>\n                            </ng-container>\n                        </ng-container>\n                        <igx-chip igxDrop (dragDrop)=\"onDimDrop($event, colArea, 1)\" #notifyChip [hidden]='true'\n                                  [displayDensity]=\"grid.displayDensity\">\n                            {{grid.resourceStrings.igx_grid_pivot_column_drop_chip}}\n                        </igx-chip>\n                    </igx-chips-area>\n                </div>\n\n                <div #pivotValueContainer *ngIf=\"grid.showPivotConfigurationUI\" class=\"igx-grid__tr-pivot\"\n                     (pointerdown)=\"$event.preventDefault()\" (dropped)=\"onValueDrop($event, valueArea)\" igxDrop\n                     (igxDragLeave)=\"onAreaDragLeave($event, valueArea)\">\n                    <!-- Value area -->\n                    <igx-chips-area #valueArea droppable='true'>\n                    <span id='empty' (dropped)=\"onValueDrop($event, valueArea)\" igxDrop *ngIf=\"grid.values.length === 0\"\n                        class='igx-grid__pivot-empty-chip-area'>{{grid.resourceStrings.igx_grid_pivot_empty_value_drop_area}}</span>\n                    <ng-container *ngFor=\"let value of grid.values; let last = last;\">\n                        <span [style.visibility]='\"hidden\"' class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                              [style.height.px]='getAreaHeight(valueArea)'></span>\n                            <igx-chip #currChip [draggable]=\"true\" [id]=\"value.displayName || value.member\" [data]=\"{ pivotArea: 'value' }\"\n                                      [displayDensity]=\"grid.displayDensity\" [removable]=\"true\" (remove)=\"valueRemoved($event)\"\n                                      (dragLeave)=\"onDimDragLeave($event)\" (dragOver)=\"onDimDragOver($event)\"\n                                      (dragDrop)=\"onValueDrop($event, valueArea)\">\n                                <div class=\"igx-grid__tr-pivot-toggle-icons\" igxPrefix\n                                     (click)='onSummaryClick($event, value, dropdown, currChip)'\n                                     (pointerdown)='$event.stopPropagation()' [igxDropDownItemNavigation]=\"dropdown\">\n                                    <igx-icon>functions</igx-icon>\n                                    <igx-icon>arrow_drop_down</igx-icon>\n                                </div>\n                                {{value.aggregate.key}}({{value.displayName || value.member}})\n                            </igx-chip>\n                            <ng-container *ngIf='last'>\n                            <span [style.visibility]='\"hidden\"' class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                                  [style.height.px]='getAreaHeight(valueArea)'></span>\n                            </ng-container>\n                        </ng-container>\n                        <igx-chip igxDrop (dragDrop)=\"onValueDrop($event, valueArea)\" #notifyValueChip [hidden]='true'\n                                  [displayDensity]=\"grid.displayDensity\">\n                            {{grid.resourceStrings.igx_grid_pivot_value_drop_chip}}\n                        </igx-chip>\n                    </igx-chips-area>\n                </div>\n            </div>\n        </div>\n    </div>\n    <div role=\"rowgroup\" class=\"igx-grid-thead__wrapper\" [style.width.px]=\"width\"\n         [attr.aria-activedescendant]=\"activeDescendant\" [class.igx-grid__tr--mrl]=\"hasMRL\">\n\n        <!-- Column headers area -->\n        <div class=\"igx-grid__tr\" role=\"row\" [style.width.px]=\"width\">\n            <div #pivotContainer class=\"igx-grid__tr-pivot igx-grid__tr-pivot--row-area\"\n                 [style.width.px]=\"grid.pivotRowWidths - 1\" (igxDragLeave)=\"onAreaDragLeave($event, rowArea)\" igxDrop\n                 (dropped)=\"onDimDrop($event, rowArea, 0)\" (pointerdown)=\"$event.preventDefault()\">\n                <!-- Row area -->\n                <igx-chips-area #rowArea droppable='true'>\n                    <ng-container *ngIf=\"grid.showPivotConfigurationUI\">\n                    <span id='empty' igxDrop (dropped)=\"onDimDrop($event, rowArea, 0)\"\n                        *ngIf=\"grid.rowDimensions.length === 0 && grid.showPivotConfigurationUI\"\n                        class='igx-grid__pivot-empty-chip-area'>{{grid.resourceStrings.igx_grid_pivot_empty_row_drop_area}}</span>\n                    <ng-container *ngFor=\"let row of grid.rowDimensions; let last = last;\">\n                        <span [style.visibility]='\"hidden\"' class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                              [style.height.px]='getAreaHeight(rowArea)'></span>\n                            <igx-chip [draggable]=\"true\" [id]=\"row.memberName\" [displayDensity]=\"grid.displayDensity\" [data]=\"{ pivotArea: 'row' }\"\n                                      [removable]=\"true\" (remove)=\"rowRemoved($event)\" (dragLeave)=\"onDimDragLeave($event)\"\n                                      (dragDrop)=\"onDimDrop($event, rowArea, 0)\" (dragOver)=\"onDimDragOver($event, 0)\"\n                                      (moveStart)='onDimDragStart($event, rowArea)' (moveEnd)='onDimDragEnd()'\n                                      (click)=\"onChipSort($event, row)\">\n                                <igx-icon igxPrefix>table_rows</igx-icon>\n                                <igx-icon igxPrefix (pointerdown)='onFilteringIconPointerDown($event)'\n                                          (click)='onFilteringIconClick($event, row)'>filter_list</igx-icon>\n                                {{ row.memberName}}\n                                <igx-icon *ngIf=\"row.sortDirection\" igxSuffix> {{ row.sortDirection < 2 ? 'arrow_upward'\n                                    : 'arrow_downward' }}</igx-icon>\n                            </igx-chip>\n                            <ng-container *ngIf='last'>\n                            <span [style.visibility]='\"hidden\"' class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                                  [style.height.px]='getAreaHeight(rowArea)'></span>\n                            </ng-container>\n                        </ng-container>\n                        <igx-chip igxDrop (dragDrop)=\"onDimDrop($event, rowArea, 0)\" #notifyChip [hidden]='true'\n                                  [displayDensity]=\"grid.displayDensity\">\n                            {{grid.resourceStrings.igx_grid_pivot_row_drop_chip}}\n                        </igx-chip>\n                    </ng-container>\n                </igx-chips-area>\n            </div>\n\n            <!-- Pinned columns collection from the start -->\n            <ng-container *ngIf=\"pinnedColumnCollection.length && grid.isPinningToStart\">\n                <ng-container *ngFor=\"let column of pinnedColumnCollection | igxTopLevel\">\n                    <igx-grid-header-group [ngClass]=\"column.headerGroupClasses\"\n                                           [ngStyle]=\"column.headerGroupStyles | igxHeaderGroupStyle:column:grid.pipeTrigger\" [column]=\"column\"\n                                           [style.min-width]=\"column.calcWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                           [style.flex-basis]=\"column.calcWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                           (pointerdown)=\"grid.navigation.focusOutRowHeader($event)\">\n                    </igx-grid-header-group>\n                </ng-container>\n            </ng-container>\n            <div class=\"igx-grid-thead--virtualizationWrapper\" [style.max-height.px]='maxContainerHeight'>\n                <div class=\"igx-grid-thead__group igx-grid-thead--virtualizationContainer\" [style.height.px]='totalDepth > 1 ? grid.rowHeight : undefined' *ngFor='let dimLevelColumns of columnDimensionsByLevel; let i = index' [style.width.px]='grid.unpinnedWidth'>\n                    <ng-template igxGridFor #headerVirtualContainer let-column\n                                 [igxGridForOf]=\"dimLevelColumns\" [igxGridForOfUniqueSizeCache] = 'true' [igxForScrollContainer]=\"grid.parentVirtDir\"\n                                 [igxForContainerSize]=\"grid.unpinnedWidth\" [igxForTrackBy]=\"grid.trackColumnChanges\"\n                                 [igxForSizePropName]=\"'calcPixelWidth'\" [igxForScrollOrientation]=\"'horizontal'\">\n                        <igx-grid-header-group [ngClass]=\"column.headerGroupClasses\"\n                                               [style.height.px]='totalDepth > 1 ? calcHeight(column, i) : undefined'\n                                               [ngStyle]=\"column.headerGroupStyles |igxHeaderGroupStyle:column:grid.pipeTrigger\" [column]=\"column\"\n                                               [style.min-width]=\"column.calcWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                               [style.flex-basis]=\"column.calcWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                               [class.igx-grid__tr-pivot--columnDimensionLeaf] = 'isDuplicateOfExistingParent(column, i)'\n                                               [class.igx-grid__tr-pivot--columnMultiRowSpan] = 'isMultiRow(column, i)'\n                        >\n                        </igx-grid-header-group>\n                    </ng-template>\n                </div>\n            </div>\n\n            <!-- Pinned columns collection at the end -->\n            <ng-container *ngIf=\"pinnedColumnCollection.length && !grid.isPinningToStart\">\n                <ng-container *ngFor=\"let column of pinnedColumnCollection | igxTopLevel\">\n                    <igx-grid-header-group [ngClass]=\"column.headerGroupClasses\"\n                                           [ngStyle]=\"column.headerGroupStyles |igxHeaderGroupStyle:column:grid.pipeTrigger\" [column]=\"column\"\n                                           [style.min-width]=\"column.calcWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                           [style.flex-basis]=\"column.calcWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                           [style.left]=\"column.rightPinnedOffset\" (pointerdown)=\"grid.navigation.focusOutRowHeader($event)\">\n                    </igx-grid-header-group>\n                </ng-container>\n            </ng-container>\n        </div>\n    </div>\n</div>\n<!-- Header thumb area -->\n<div class=\"igx-grid-thead__thumb\" [hidden]=\"!grid.hasVerticalScroll()\" [style.width.px]=\"grid.scrollSize\">\n</div>\n\n<igx-drop-down #dropdown (selectionChanging)='onAggregationChange($event)'>\n    <igx-drop-down-item *ngFor=\"let item of aggregateList\" [selected]='isSelected(item)' [value]='item'>\n        {{ item.label }}\n    </igx-drop-down-item>\n</igx-drop-down>\n\n<div [hidden]='true'>\n    <igx-grid-excel-style-filtering [maxHeight]='grid.excelStyleFilterMaxHeight' [minHeight]='grid.excelStyleFilterMinHeight' #esf>\n        <div igxExcelStyleColumnOperations>\n            <igx-chips-area #dropdownChips>\n                <igx-chip *ngFor=\"let filter of this.filterDropdownDimensions\" [id]=\"filter.memberName\"\n                [displayDensity]=\"grid.displayDensity\" [removable]=\"true\" (remove)=\"filterRemoved($event)\"\n                (chipClick)='onFiltersSelectionChanged($event)' [selectable]='true' [selected]='filter === this.filterDropdownDimensions.values().next().value'>\n                {{filter.memberName}}\n            </igx-chip>\n        </igx-chips-area>\n        </div>\n        <igx-excel-style-filter-operations>\n            <igx-excel-style-search></igx-excel-style-search>\n        </igx-excel-style-filter-operations>\n    </igx-grid-excel-style-filtering>\n</div>\n\n<div style=\"visibility: hidden; position: absolute; top: -10000px\">\n    <igx-chips-area #filterAreaHidden droppable='true'>\n        <igx-chip *ngFor=\"let filter of grid.filterDimensions\" [id]=\"filter.memberName\" [draggable]=\"true\"\n            [displayDensity]=\"grid.displayDensity\" [removable]=\"true\" (remove)=\"filterRemoved($event)\">\n            <igx-icon igxPrefix>filter_list</igx-icon>\n            {{filter.memberName}}\n        </igx-chip>\n    </igx-chips-area>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [IGX_GRID_BASE]
                }] }, { type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: i0.Renderer2 }]; }, propDecorators: { esf: [{
                type: ViewChild,
                args: ['esf']
            }], filterArea: [{
                type: ViewChild,
                args: ['filterAreaHidden', { static: false }]
            }], filtersButton: [{
                type: ViewChild,
                args: ['filterIcon']
            }], dropdownChips: [{
                type: ViewChild,
                args: ['dropdownChips']
            }], pivotFilterContainer: [{
                type: ViewChild,
                args: ['pivotFilterContainer']
            }], notificationChips: [{
                type: ViewChildren,
                args: ['notifyChip']
            }], headerContainers: [{
                type: ViewChildren,
                args: ['headerVirtualContainer', { read: IgxGridForOfDirective }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGl2b3QtaGVhZGVyLXJvdy5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvZ3JpZHMvcGl2b3QtZ3JpZC9waXZvdC1oZWFkZXItcm93LmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9ncmlkcy9waXZvdC1ncmlkL3Bpdm90LWhlYWRlci1yb3cuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNILHVCQUF1QixFQUV2QixTQUFTLEVBRVQsTUFBTSxFQUlOLFNBQVMsRUFFVCxZQUFZLEVBQ2YsTUFBTSxlQUFlLENBQUM7QUFJdkIsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sd0NBQXdDLENBQUM7QUFDMUUsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sMENBQTBDLENBQUM7QUFHakYsT0FBTyxFQUFFLHNCQUFzQixFQUFFLG9CQUFvQixFQUFxQyxpQkFBaUIsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQy9JLE9BQU8sRUFBYyxhQUFhLEVBQWlCLE1BQU0sMEJBQTBCLENBQUM7QUFFcEYsT0FBTyxFQUFFLHlCQUF5QixFQUFFLE1BQU0sc0NBQXNDLENBQUM7QUFDakYsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBRXhELE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxjQUFjLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFekM7Ozs7Ozs7R0FPRztBQU1ILE1BQU0sT0FBTywwQkFBMkIsU0FBUSx5QkFBeUI7SUErRHJFLFlBQ2tDLElBQW1CLEVBQ3ZDLEdBQTRCLEVBQzVCLEdBQXNCLEVBQ3RCLFFBQW1CO1FBRTdCLEtBQUssQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFMYyxTQUFJLEdB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MEJBQTBCLHVzQkF3RGEscUJBQXFCLHlFQ2pHekUsMHFrQkE2T0E7MkZEcE1hLDBCQUEwQjtrQkFMdEMsU0FBUztzQ0FDVyx1QkFBdUIsQ0FBQyxNQUFNLFlBQ3JDLHNCQUFzQjs7MEJBbUUzQixNQUFNOzJCQUFDLGFBQWE7NkhBMUNBLEdBQUc7c0JBQTNCLFNBQVM7dUJBQUMsS0FBSztnQkFLeUMsVUFBVTtzQkFBbEUsU0FBUzt1QkFBQyxrQkFBa0IsRUFBRSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUU7Z0JBS2hCLGFBQWE7c0JBQTVDLFNBQVM7dUJBQUMsWUFBWTtnQkFLWSxhQUFhO3NCQUEvQyxTQUFTO3VCQUFDLGVBQWU7Z0JBS2dCLG9CQUFvQjtzQkFBN0QsU0FBUzt1QkFBQyxzQkFBc0I7Z0JBTzFCLGlCQUFpQjtzQkFEdkIsWUFBWTt1QkFBQyxZQUFZO2dCQVNuQixnQkFBZ0I7c0JBRHRCLFlBQVk7dUJBQUMsd0JBQXdCLEVBQUUsRUFBRSxJQUFJLEVBQUUscUJBQXFCLEVBQUUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgIENvbXBvbmVudCxcbiAgICBFbGVtZW50UmVmLFxuICAgIEluamVjdCxcbiAgICBPbkNoYW5nZXMsXG4gICAgUXVlcnlMaXN0LFxuICAgIFJlbmRlcmVyMixcbiAgICBWaWV3Q2hpbGQsXG4gICAgU2ltcGxlQ2hhbmdlcyxcbiAgICBWaWV3Q2hpbGRyZW5cbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBmaXJzdCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IElCYXNlQ2hpcEV2ZW50QXJncywgSWd4Q2hpcENvbXBvbmVudCB9IGZyb20gJy4uLy4uL2NoaXBzL2NoaXAuY29tcG9uZW50JztcbmltcG9ydCB7IElneENoaXBzQXJlYUNvbXBvbmVudCB9IGZyb20gJy4uLy4uL2NoaXBzL2NoaXBzLWFyZWEuY29tcG9uZW50JztcbmltcG9ydCB7IFNvcnRpbmdEaXJlY3Rpb24gfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvc29ydGluZy1zdHJhdGVneSc7XG5pbXBvcnQgeyBJZ3hHcmlkRm9yT2ZEaXJlY3RpdmUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2Zvci1vZi9mb3Jfb2YuZGlyZWN0aXZlJztcbmltcG9ydCB7IElTZWxlY3Rpb25FdmVudEFyZ3MgfSBmcm9tICcuLi8uLi9kcm9wLWRvd24vZHJvcC1kb3duLmNvbW1vbic7XG5pbXBvcnQgeyBJZ3hEcm9wRG93bkNvbXBvbmVudCB9IGZyb20gJy4uLy4uL2Ryb3AtZG93bi9kcm9wLWRvd24uY29tcG9uZW50JztcbmltcG9ydCB7IEFic29sdXRlU2Nyb2xsU3RyYXRlZ3ksIEF1dG9Qb3NpdGlvblN0cmF0ZWd5LCBPdmVybGF5U2V0dGluZ3MsIFBvc2l0aW9uU2V0dGluZ3MsIFZlcnRpY2FsQWxpZ25tZW50IH0gZnJvbSAnLi4vLi4vc2VydmljZXMvcHVibGljX2FwaSc7XG5pbXBvcnQgeyBDb2x1bW5UeXBlLCBJR1hfR1JJRF9CQVNFLCBQaXZvdEdyaWRUeXBlIH0gZnJvbSAnLi4vY29tbW9uL2dyaWQuaW50ZXJmYWNlJztcbmltcG9ydCB7IElneEdyaWRIZWFkZXJHcm91cENvbXBvbmVudCB9IGZyb20gJy4uL2hlYWRlcnMvZ3JpZC1oZWFkZXItZ3JvdXAuY29tcG9uZW50JztcbmltcG9ydCB7IElneEdyaWRIZWFkZXJSb3dDb21wb25lbnQgfSBmcm9tICcuLi9oZWFkZXJzL2dyaWQtaGVhZGVyLXJvdy5jb21wb25lbnQnO1xuaW1wb3J0IHsgRHJvcFBvc2l0aW9uIH0gZnJvbSAnLi4vbW92aW5nL21vdmluZy5zZXJ2aWNlJztcbmltcG9ydCB7IElQaXZvdEFnZ3JlZ2F0b3IsIElQaXZvdERpbWVuc2lvbiwgSVBpdm90VmFsdWUsIFBpdm90RGltZW5zaW9uVHlwZSB9IGZyb20gJy4vcGl2b3QtZ3JpZC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgUGl2b3RVdGlsIH0gZnJvbSAnLi9waXZvdC11dGlsJztcblxuLyoqXG4gKlxuICogRm9yIGFsbCBpbnRlbnRzICYgcHVycG9zZXMgdHJlYXQgdGhpcyBjb21wb25lbnQgYXMgd2hhdCBhIDx0aGVhZD4gdXN1YWxseSBpcyBpbiB0aGUgZGVmYXVsdCA8dGFibGU+IGVsZW1lbnQuXG4gKlxuICogVGhpcyBjb250YWluZXIgaG9sZHMgdGhlIHBpdm90IGdyaWQgaGVhZGVyIGVsZW1lbnRzIGFuZCB0aGVpciBiZWhhdmlvci9pbnRlcmFjdGlvbnMuXG4gKlxuICogQGhpZGRlbiBAaW50ZXJuYWxcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgc2VsZWN0b3I6ICdpZ3gtcGl2b3QtaGVhZGVyLXJvdycsXG4gICAgdGVtcGxhdGVVcmw6ICcuL3Bpdm90LWhlYWRlci1yb3cuY29tcG9uZW50Lmh0bWwnXG59KVxuZXhwb3J0IGNsYXNzIElneFBpdm90SGVhZGVyUm93Q29tcG9uZW50IGV4dGVuZHMgSWd4R3JpZEhlYWRlclJvd0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcyB7XG4gICAgcHVibGljIGFnZ3JlZ2F0ZUxpc3Q6IElQaXZvdEFnZ3JlZ2F0b3JbXSA9IFtdO1xuXG4gICAgcHVibGljIHZhbHVlOiBJUGl2b3RWYWx1ZTtcbiAgICBwdWJsaWMgZmlsdGVyRHJvcGRvd25EaW1lbnNpb25zOiBTZXQ8YW55PiA9IG5ldyBTZXQ8YW55PigpO1xuICAgIHB1YmxpYyBmaWx0ZXJBcmVhRGltZW5zaW9uczogU2V0PGFueT4gPSBuZXcgU2V0PGFueT4oKTtcbiAgICBwcml2YXRlIF9kcm9wUG9zID0gRHJvcFBvc2l0aW9uLkFmdGVyRHJvcFRhcmdldDtcbiAgICBwcml2YXRlIHZhbHVlRGF0YTogTWFwPHN0cmluZywgSVBpdm90QWdncmVnYXRvcltdPjtcbiAgICBwcml2YXRlIF9zdWJNZW51UG9zaXRpb25TZXR0aW5nczogUG9zaXRpb25TZXR0aW5ncyA9IHtcbiAgICAgICAgdmVydGljYWxTdGFydFBvaW50OiBWZXJ0aWNhbEFsaWdubWVudC5Cb3R0b20sXG4gICAgICAgIGNsb3NlQW5pbWF0aW9uOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIHByaXZhdGUgX3N1Yk1lbnVPdmVybGF5U2V0dGluZ3M6IE92ZXJsYXlTZXR0aW5ncyA9IHtcbiAgICAgICAgY2xvc2VPbk91dHNpZGVDbGljazogdHJ1ZSxcbiAgICAgICAgbW9kYWw6IGZhbHNlLFxuICAgICAgICBwb3NpdGlvblN0cmF0ZWd5OiBuZXcgQXV0b1Bvc2l0aW9uU3RyYXRlZ3kodGhpcy5fc3ViTWVudVBvc2l0aW9uU2V0dGluZ3MpLFxuICAgICAgICBzY3JvbGxTdHJhdGVneTogbmV3IEFic29sdXRlU2Nyb2xsU3RyYXRlZ3koKVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ2VzZicpIHB1YmxpYyBlc2Y6IGFueTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgnZmlsdGVyQXJlYUhpZGRlbicsIHsgc3RhdGljOiBmYWxzZSB9KSBwdWJsaWMgZmlsdGVyQXJlYTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgnZmlsdGVySWNvbicpIHB1YmxpYyBmaWx0ZXJzQnV0dG9uO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCdkcm9wZG93bkNoaXBzJykgcHVibGljIGRyb3Bkb3duQ2hpcHM7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ3Bpdm90RmlsdGVyQ29udGFpbmVyJykgcHVibGljIHBpdm90RmlsdGVyQ29udGFpbmVyO1xuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIEBWaWV3Q2hpbGRyZW4oJ25vdGlmeUNoaXAnKVxuICAgIHB1YmxpYyBub3RpZmljYXRpb25DaGlwczogUXVlcnlMaXN0PElneENoaXBDb21wb25lbnQ+O1xuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqIFRoZSB2aXJ0dWFsaXplZCBwYXJ0IG9mIHRoZSBoZWFkZXIgcm93IGNvbnRhaW5pbmcgdGhlIHVucGlubmVkIGhlYWRlciBncm91cHMuXG4gICAgKi9cbiAgICBAVmlld0NoaWxkcmVuKCdoZWFkZXJWaXJ0dWFsQ29udGFpbmVyJywgeyByZWFkOiBJZ3hHcmlkRm9yT2ZEaXJlY3RpdmUgfSlcbiAgICBwdWJsaWMgaGVhZGVyQ29udGFpbmVyczogUXVlcnlMaXN0PElneEdyaWRGb3JPZkRpcmVjdGl2ZTxJZ3hHcmlkSGVhZGVyR3JvdXBDb21wb25lbnQ+PjtcblxuICAgIHB1YmxpYyBnZXQgaGVhZGVyRm9yT2YoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYWRlckNvbnRhaW5lcnMubGFzdDtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgQEluamVjdChJR1hfR1JJRF9CQVNFKSBwdWJsaWMgZ3JpZDogUGl2b3RHcmlkVHlwZSxcbiAgICAgICAgcHJvdGVjdGVkIHJlZjogRWxlbWVudFJlZjxIVE1MRWxlbWVudD4sXG4gICAgICAgIHByb3RlY3RlZCBjZHI6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBwcm90ZWN0ZWQgcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICApIHtcbiAgICAgICAgc3VwZXIocmVmLCBjZHIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKiBEZWZhdWx0IGlzIGEgc2luZ2xlIGVtcHR5IGxldmVsIHNpbmNlIGRlZmF1bHQgZGVwdGggaXMgMVxuICAgICovXG4gICAgcHVibGljIGNvbHVtbkRpbWVuc2lvbnNCeUxldmVsOiBhbnlbXSA9IFtbXV07XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgKi9cbiAgICBwdWJsaWMgZ2V0IGlzRmlsdGVyc0J1dHRvbigpOiBib29sZWFuIHtcbiAgICAgICAgbGV0IGNoaXBzV2lkdGggPSAwO1xuICAgICAgICB0aGlzLmZpbHRlckRyb3Bkb3duRGltZW5zaW9ucy5jbGVhcigpO1xuICAgICAgICB0aGlzLmZpbHRlckFyZWFEaW1lbnNpb25zLmNsZWFyKCk7XG4gICAgICAgIGlmICh0aGlzLmZpbHRlckFyZWE/LmNoaXBzTGlzdCAmJiB0aGlzLmZpbHRlckFyZWEuY2hpcHNMaXN0Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgY29uc3Qgc3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLnBpdm90RmlsdGVyQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyUGFkZGluZ3MgPSBwYXJzZUZsb2F0KHN0eWxlcy5wYWRkaW5nTGVmdCkgKyBwYXJzZUZsb2F0KHN0eWxlcy5wYWRkaW5nUmlnaHQpO1xuICAgICAgICAgICAgY2hpcHNXaWR0aCArPSBjb250YWluZXJQYWRkaW5ncyArICh0aGlzLmZpbHRlcnNCdXR0b24gJiYgdGhpcy5maWx0ZXJBcmVhPy5jaGlwc0xpc3QubGVuZ3RoID4gMSA/IHRoaXMuZmlsdGVyc0J1dHRvbi5lbC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIDogMCk7XG4gICAgICAgICAgICB0aGlzLmZpbHRlckFyZWEuY2hpcHNMaXN0LmZvckVhY2goY2hpcCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGltID0gdGhpcy5ncmlkLmZpbHRlckRpbWVuc2lvbnMuZmluZCh4ID0+IHgubWVtYmVyTmFtZSA9PT0gY2hpcC5pZCk7XG4gICAgICAgICAgICAgICAgaWYgKGRpbSkge1xuICAgICAgICAgICAgICAgICAgICAvLyA4IHB4IG1hcmdpbiBiZXR3ZWVuIGNoaXBzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDaGlwV2lkdGggPSBjaGlwLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKyA4O1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpcHNXaWR0aCArIGN1cnJlbnRDaGlwV2lkdGggPCB0aGlzLmdyaWQucGl2b3RSb3dXaWR0aHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyQXJlYURpbWVuc2lvbnMuYWRkKGRpbSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlckRyb3Bkb3duRGltZW5zaW9ucy5hZGQoZGltKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaGlwc1dpZHRoICs9IGN1cnJlbnRDaGlwV2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJEcm9wZG93bkRpbWVuc2lvbnMuc2l6ZSA+IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKi9cbiAgICBwdWJsaWMgZ2V0IHRvdGFsRGVwdGgoKSB7XG4gICAgICAgIGNvbnN0IGNvbHVtbkRpbWVuc2lvbnMgPSB0aGlzLmdyaWQuY29sdW1uRGltZW5zaW9ucztcbiAgICAgICAgaWYgKGNvbHVtbkRpbWVuc2lvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG90YWxEZXB0aCA9IGNvbHVtbkRpbWVuc2lvbnMubWFwKHggPT4gUGl2b3RVdGlsLmdldERpbWVuc2lvbkRlcHRoKHgpICsgMSkucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjICsgdmFsKTtcbiAgICAgICAgaWYgKHRoaXMuZ3JpZC5oYXNNdWx0aXBsZVZhbHVlcykge1xuICAgICAgICAgICAgdG90YWxEZXB0aCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbERlcHRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKi9cbiAgICBwdWJsaWMgZ2V0IG1heENvbnRhaW5lckhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG90YWxEZXB0aCAqIHRoaXMuZ3JpZC5yZW5kZXJlZFJvd0hlaWdodDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVibGljIGNhbGNIZWlnaHQoY29sOiBDb2x1bW5UeXBlLCBpbmRleDogbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiAhY29sLmNvbHVtbkdyb3VwICYmIGNvbC5sZXZlbCA8IHRoaXMudG90YWxEZXB0aCAmJiBjb2wubGV2ZWwgPT09IGluZGV4ID8gKHRoaXMudG90YWxEZXB0aCAtIGNvbC5sZXZlbCkgKiB0aGlzLmdyaWQucm93SGVpZ2h0IDogdGhpcy5ncmlkLnJvd0hlaWdodDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVibGljIGlzRHVwbGljYXRlT2ZFeGlzdGluZ1BhcmVudChjb2w6IENvbHVtblR5cGUsIGx2bDogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudENvbGxlY3Rpb24gPSBsdmwgPiAwID8gdGhpcy5jb2x1bW5EaW1lbnNpb25zQnlMZXZlbFtsdmwgLSAxXSA6IFtdO1xuICAgICAgICBjb25zdCBkdXBsaWNhdGUgPSBwYXJlbnRDb2xsZWN0aW9uLmluZGV4T2YoY29sKSAhPT0gLTE7XG5cbiAgICAgICAgcmV0dXJuIGR1cGxpY2F0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVibGljIGlzTXVsdGlSb3coY29sOiBDb2x1bW5UeXBlLCBsdmw6IG51bWJlcikge1xuICAgICAgICBjb25zdCBpc0xlYWYgPSAhY29sLmNvbHVtbkdyb3VwO1xuICAgICAgICByZXR1cm4gaXNMZWFmICYmIGx2bCAhPT0gdGhpcy50b3RhbERlcHRoIC0gMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVibGljIHBvcHVsYXRlQ29sdW1uRGltZW5zaW9uc0J5TGV2ZWwoKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudG90YWxEZXB0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXNbaV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb2xzID0gdGhpcy51bnBpbm5lZENvbHVtbkNvbGxlY3Rpb247XG4gICAgICAgIC8vIHBvcHVsYXRlIGNvbHVtbiBkaW1lbnNpb24gbWF0cml4IHJlY3Vyc2l2ZWx5XG4gICAgICAgIHRoaXMucG9wdWxhdGVEaW1lbnNpb25SZWN1cnNpdmVseShjb2xzLmZpbHRlcih4ID0+IHgubGV2ZWwgPT09IDApLCAwLCByZXMpO1xuICAgICAgICB0aGlzLmNvbHVtbkRpbWVuc2lvbnNCeUxldmVsID0gcmVzO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBwb3B1bGF0ZURpbWVuc2lvblJlY3Vyc2l2ZWx5KGN1cnJlbnRMZXZlbENvbHVtbnM6IENvbHVtblR5cGVbXSwgbGV2ZWwgPSAwLCByZXM6IGFueVtdKSB7XG4gICAgICAgIGN1cnJlbnRMZXZlbENvbHVtbnMuZm9yRWFjaChjb2wgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc1tsZXZlbF0pIHtcbiAgICAgICAgICAgICAgICByZXNbbGV2ZWxdLnB1c2goY29sKTtcbiAgICAgICAgICAgICAgICBpZiAoY29sLmNvbHVtbkdyb3VwICYmIGNvbC5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpc2libGVDb2x1bW5zID0gY29sLmNoaWxkcmVuLnRvQXJyYXkoKS5maWx0ZXIoeCA9PiAheC5oaWRkZW4pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcHVsYXRlRGltZW5zaW9uUmVjdXJzaXZlbHkodmlzaWJsZUNvbHVtbnMsIGxldmVsICsgMSwgcmVzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxldmVsIDwgdGhpcy50b3RhbERlcHRoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbGV2ZWwgKyAxOyBpIDw9IHRoaXMudG90YWxEZXB0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzW2ldLnB1c2goY29sKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1YmxpYyBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLnVucGlubmVkQ29sdW1uQ29sbGVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5wb3B1bGF0ZUNvbHVtbkRpbWVuc2lvbnNCeUxldmVsKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVibGljIG9uRGltRHJhZ1N0YXJ0KGV2ZW50LCBhcmVhKSB7XG4gICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgZm9yIChsZXQgY2hpcCBvZiB0aGlzLm5vdGlmaWNhdGlvbkNoaXBzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBjaGlwLm5hdGl2ZUVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIGlmIChhcmVhLmNoaXBzTGlzdC50b0FycmF5KCkuaW5kZXhPZihjaGlwKSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5pdGVtKDApLmlkICE9PSAnZW1wdHknKSB7XG4gICAgICAgICAgICAgICAgY2hpcC5uYXRpdmVFbGVtZW50LmhpZGRlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHBhcmVudC5wYXJlbnRFbGVtZW50LnNjcm9sbFRvKHsgbGVmdDogY2hpcC5uYXRpdmVFbGVtZW50Lm9mZnNldExlZnQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVibGljIG9uRGltRHJhZ0VuZCgpIHtcbiAgICAgICAgZm9yIChsZXQgY2hpcCBvZiB0aGlzLm5vdGlmaWNhdGlvbkNoaXBzKSB7XG4gICAgICAgICAgICBjaGlwLm5hdGl2ZUVsZW1lbnQuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKi9cbiAgICBwdWJsaWMgZ2V0QXJlYUhlaWdodChhcmVhOiBJZ3hDaGlwc0FyZWFDb21wb25lbnQpIHtcbiAgICAgICAgY29uc3QgY2hpcHMgPSBhcmVhLmNoaXBzTGlzdDtcbiAgICAgICAgcmV0dXJuIGNoaXBzICYmIGNoaXBzLmxlbmd0aCA+IDAgPyBjaGlwcy5maXJzdC5uYXRpdmVFbGVtZW50Lm9mZnNldEhlaWdodCA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1YmxpYyByb3dSZW1vdmVkKGV2ZW50OiBJQmFzZUNoaXBFdmVudEFyZ3MpIHtcbiAgICAgICAgY29uc3Qgcm93ID0gdGhpcy5ncmlkLnBpdm90Q29uZmlndXJhdGlvbi5yb3dzLmZpbmQoeCA9PiB4Lm1lbWJlck5hbWUgPT09IGV2ZW50Lm93bmVyLmlkKTtcbiAgICAgICAgdGhpcy5ncmlkLnRvZ2dsZURpbWVuc2lvbihyb3cpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKi9cbiAgICBwdWJsaWMgY29sdW1uUmVtb3ZlZChldmVudDogSUJhc2VDaGlwRXZlbnRBcmdzKSB7XG4gICAgICAgIGNvbnN0IGNvbCA9IHRoaXMuZ3JpZC5waXZvdENvbmZpZ3VyYXRpb24uY29sdW1ucy5maW5kKHggPT4geC5tZW1iZXJOYW1lID09PSBldmVudC5vd25lci5pZCk7XG4gICAgICAgIHRoaXMuZ3JpZC50b2dnbGVEaW1lbnNpb24oY29sKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVibGljIHZhbHVlUmVtb3ZlZChldmVudDogSUJhc2VDaGlwRXZlbnRBcmdzKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5ncmlkLnBpdm90Q29uZmlndXJhdGlvbi52YWx1ZXMuZmluZCh4ID0+IHgubWVtYmVyID09PSBldmVudC5vd25lci5pZCB8fCB4LmRpc3BsYXlOYW1lID09PSBldmVudC5vd25lci5pZCk7XG4gICAgICAgIHRoaXMuZ3JpZC50b2dnbGVWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1YmxpYyBmaWx0ZXJSZW1vdmVkKGV2ZW50OiBJQmFzZUNoaXBFdmVudEFyZ3MpIHtcbiAgICAgICAgY29uc3QgZmlsdGVyID0gdGhpcy5ncmlkLnBpdm90Q29uZmlndXJhdGlvbi5maWx0ZXJzLmZpbmQoeCA9PiB4Lm1lbWJlck5hbWUgPT09IGV2ZW50Lm93bmVyLmlkKTtcbiAgICAgICAgdGhpcy5ncmlkLnRvZ2dsZURpbWVuc2lvbihmaWx0ZXIpO1xuICAgICAgICBpZiAodGhpcy5maWx0ZXJEcm9wZG93bkRpbWVuc2lvbnMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMub25GaWx0ZXJzQXJlYURyb3Bkb3duQ2xpY2soeyB0YXJnZXQ6IHRoaXMuZmlsdGVyc0J1dHRvbi5lbC5uYXRpdmVFbGVtZW50IH0sIHVuZGVmaW5lZCwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ncmlkLmZpbHRlcmluZ1NlcnZpY2UuaGlkZUVTRigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIG9uRmlsdGVyc1NlbGVjdGlvbkNoYW5nZWQoZXZlbnQ/OiBJQmFzZUNoaXBFdmVudEFyZ3MpIHtcbiAgICAgICAgdGhpcy5kcm9wZG93bkNoaXBzLmNoaXBzTGlzdC5mb3JFYWNoKGNoaXAgPT4ge1xuICAgICAgICAgICAgaWYgKGNoaXAuaWQgIT09IGV2ZW50Lm93bmVyLmlkKSB7XG4gICAgICAgICAgICAgICAgY2hpcC5zZWxlY3RlZCA9IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uRmlsdGVyc0FyZWFEcm9wZG93bkNsaWNrKHsgdGFyZ2V0OiB0aGlzLmZpbHRlcnNCdXR0b24uZWwubmF0aXZlRWxlbWVudCB9LCB0aGlzLmdyaWQuZmlsdGVyRGltZW5zaW9ucy5maW5kKGRpbSA9PiBkaW0ubWVtYmVyTmFtZSA9PT0gZXZlbnQub3duZXIuaWQpLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1YmxpYyBvbkZpbHRlcmluZ0ljb25Qb2ludGVyRG93bihldmVudCkge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVibGljIG9uRmlsdGVyaW5nSWNvbkNsaWNrKGV2ZW50LCBkaW1lbnNpb24pIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGxldCBkaW0gPSBkaW1lbnNpb247XG4gICAgICAgIGNvbnN0IGNvbCA9IHRoaXMuZ3JpZC5kaW1lbnNpb25EYXRhQ29sdW1ucy5maW5kKHggPT4geC5maWVsZCA9PT0gZGltLm1lbWJlck5hbWUgfHwgeC5maWVsZCA9PT0gZGltLm1lbWJlcik7XG4gICAgICAgIHRoaXMuZ3JpZC5maWx0ZXJpbmdTZXJ2aWNlLnRvZ2dsZUZpbHRlckRyb3Bkb3duKGV2ZW50LnRhcmdldCwgY29sKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVibGljIG9uU3VtbWFyeUNsaWNrKGV2ZW50QXJncywgdmFsdWU6IElQaXZvdFZhbHVlLCBkcm9wZG93bjogSWd4RHJvcERvd25Db21wb25lbnQsIGNoaXA6IElneENoaXBDb21wb25lbnQpIHtcbiAgICAgICAgdGhpcy5fc3ViTWVudU92ZXJsYXlTZXR0aW5ncy50YXJnZXQgPSBldmVudEFyZ3MuY3VycmVudFRhcmdldDtcbiAgICAgICAgdGhpcy51cGRhdGVEcm9wRG93bih2YWx1ZSwgZHJvcGRvd24sIGNoaXApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIG9uRmlsdGVyc0FyZWFEcm9wZG93bkNsaWNrKGV2ZW50LCBkaW1lbnNpb24/LCBzaG91bGRSZWF0dGFjaCA9IHRydWUpIHtcbiAgICAgICAgbGV0IGRpbSA9IGRpbWVuc2lvbiB8fCB0aGlzLmZpbHRlckRyb3Bkb3duRGltZW5zaW9ucy52YWx1ZXMoKS5uZXh0KCkudmFsdWU7XG4gICAgICAgIGNvbnN0IGNvbCA9IHRoaXMuZ3JpZC5kaW1lbnNpb25EYXRhQ29sdW1ucy5maW5kKHggPT4geC5maWVsZCA9PT0gZGltLm1lbWJlck5hbWUgfHwgeC5maWVsZCA9PT0gZGltLm1lbWJlcik7XG4gICAgICAgIGlmIChzaG91bGRSZWF0dGFjaCkge1xuICAgICAgICAgICAgdGhpcy5kcm9wZG93bkNoaXBzLmNoaXBzTGlzdC5mb3JFYWNoKGNoaXAgPT4ge1xuICAgICAgICAgICAgICAgIGNoaXAuc2VsZWN0ZWQgPSBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmRyb3Bkb3duQ2hpcHMuY2hpcHNMaXN0LmZpcnN0LnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdyaWQuZmlsdGVyaW5nU2VydmljZS50b2dnbGVGaWx0ZXJzRVNGKHRoaXMuZXNmLCBldmVudC50YXJnZXQsIGNvbCwgc2hvdWxkUmVhdHRhY2gpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKi9cbiAgICBwdWJsaWMgb25BZ2dyZWdhdGlvbkNoYW5nZShldmVudDogSVNlbGVjdGlvbkV2ZW50QXJncykge1xuICAgICAgICBpZiAoIXRoaXMuaXNTZWxlY3RlZChldmVudC5uZXdTZWxlY3Rpb24udmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlLmFnZ3JlZ2F0ZSA9IGV2ZW50Lm5ld1NlbGVjdGlvbi52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5waXBlVHJpZ2dlcisrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1YmxpYyBpc1NlbGVjdGVkKHZhbDogSVBpdm90QWdncmVnYXRvcikge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS5hZ2dyZWdhdGUua2V5ID09PSB2YWwua2V5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKi9cbiAgICBwdWJsaWMgb25DaGlwU29ydChfZXZlbnQsIGRpbWVuc2lvbjogSVBpdm90RGltZW5zaW9uKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0RGlyZWN0aW9uID0gZGltZW5zaW9uLnNvcnREaXJlY3Rpb24gfHwgU29ydGluZ0RpcmVjdGlvbi5Ob25lO1xuICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBzdGFydERpcmVjdGlvbiArIDEgPiBTb3J0aW5nRGlyZWN0aW9uLkRlc2MgP1xuICAgICAgICAgICAgU29ydGluZ0RpcmVjdGlvbi5Ob25lIDogc3RhcnREaXJlY3Rpb24gKyAxO1xuICAgICAgICB0aGlzLmdyaWQuc29ydERpbWVuc2lvbihkaW1lbnNpb24sIGRpcmVjdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1YmxpYyBvbkRpbURyYWdPdmVyKGV2ZW50LCBkaW1lbnNpb24/OiBQaXZvdERpbWVuc2lvblR5cGUpIHtcbiAgICAgICAgaWYgKCFldmVudC5kcmFnQ2hpcCB8fCAhZXZlbnQuZHJhZ0NoaXAuZGF0YT8ucGl2b3RBcmVhKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHR5cGVNaXNtYXRjaCA9IGRpbWVuc2lvbiAhPT0gdW5kZWZpbmVkID8gdGhpcy5ncmlkLnBpdm90Q29uZmlndXJhdGlvbi52YWx1ZXMuZmluZCh4ID0+IHgubWVtYmVyID09PSBldmVudC5kcmFnQ2hpcC5pZFxuICAgICAgICAgICAgfHwgeC5kaXNwbGF5TmFtZSA9PT0gZXZlbnQuZHJhZ0NoaXAuaWQpIDpcbiAgICAgICAgICAgICF0aGlzLmdyaWQucGl2b3RDb25maWd1cmF0aW9uLnZhbHVlcy5maW5kKHggPT4geC5tZW1iZXIgPT09IGV2ZW50LmRyYWdDaGlwLmlkIHx8IHguZGlzcGxheU5hbWUgPT09IGV2ZW50LmRyYWdDaGlwLmlkKTtcbiAgICAgICAgaWYgKHR5cGVNaXNtYXRjaCkge1xuICAgICAgICAgICAgLy8gY2Fubm90IGRyYWcgYmV0d2VlbiBkaW1lbnNpb25zIGFuZCB2YWx1ZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHdlIGFyZSBpbiB0aGUgbGVmdCBoYWxmIG9mIHRoZSBjaGlwLCBkcm9wIG9uIHRoZSBsZWZ0XG4gICAgICAgIC8vIGVsc2UgZHJvcCBvbiB0aGUgcmlnaHQgb2YgdGhlIGNoaXBcbiAgICAgICAgY29uc3QgY2xpZW50UmVjdCA9IGV2ZW50Lm93bmVyLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IHBvcyA9IGNsaWVudFJlY3Qud2lkdGggLyAyO1xuXG4gICAgICAgIHRoaXMuX2Ryb3BQb3MgPSBldmVudC5vcmlnaW5hbEV2ZW50Lm9mZnNldFggPiBwb3MgPyBEcm9wUG9zaXRpb24uQWZ0ZXJEcm9wVGFyZ2V0IDogRHJvcFBvc2l0aW9uLkJlZm9yZURyb3BUYXJnZXQ7XG4gICAgICAgIGlmICh0aGlzLl9kcm9wUG9zID09PSBEcm9wUG9zaXRpb24uQWZ0ZXJEcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgICBldmVudC5vd25lci5uYXRpdmVFbGVtZW50LnByZXZpb3VzRWxlbWVudFNpYmxpbmcuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgZXZlbnQub3duZXIubmF0aXZlRWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcuc3R5bGUudmlzaWJpbGl0eSA9ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXZlbnQub3duZXIubmF0aXZlRWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgZXZlbnQub3duZXIubmF0aXZlRWxlbWVudC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLnN0eWxlLnZpc2liaWxpdHkgPSAnJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKi9cbiAgICBwdWJsaWMgb25EaW1EcmFnTGVhdmUoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQub3duZXIubmF0aXZlRWxlbWVudC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgZXZlbnQub3duZXIubmF0aXZlRWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICB0aGlzLl9kcm9wUG9zID0gRHJvcFBvc2l0aW9uLkFmdGVyRHJvcFRhcmdldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVibGljIG9uQXJlYURyYWdMZWF2ZShldmVudCwgYXJlYSkge1xuICAgICAgICBjb25zdCBkYXRhQ2hpcHMgPSBhcmVhLmNoaXBzTGlzdC50b0FycmF5KCkuZmlsdGVyKHggPT4gdGhpcy5ub3RpZmljYXRpb25DaGlwcy50b0FycmF5KCkuaW5kZXhPZih4KSA9PT0gLTEpO1xuICAgICAgICBkYXRhQ2hpcHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50Lm5hdGl2ZUVsZW1lbnQucHJldmlvdXNFbGVtZW50U2libGluZykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQubmF0aXZlRWxlbWVudC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbGVtZW50Lm5hdGl2ZUVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5uYXRpdmVFbGVtZW50Lm5leHRFbGVtZW50U2libGluZy5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKi9cbiAgICBwdWJsaWMgb25WYWx1ZURyb3AoZXZlbnQsIGFyZWEpIHtcbiAgICAgICAgaWYgKCEoZXZlbnQuZHJhZ0NoaXAgJiYgZXZlbnQuZHJhZ0NoaXAuZGF0YT8ucGl2b3RBcmVhKSAmJiAhKGV2ZW50LmRyYWdEYXRhPy5jaGlwICYmICEhZXZlbnQuZHJhZ0RhdGEuY2hpcC5kYXRhLnBpdm90QXJlYSkpIHJldHVybjtcbiAgICAgICAgLy92YWx1ZXMgY2FuIG9ubHkgYmUgcmVvcmRlcmVkXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMuZ3JpZC5waXZvdENvbmZpZ3VyYXRpb24udmFsdWVzO1xuICAgICAgICBjb25zdCBkcmFnSWQgPSBldmVudC5kcmFnQ2hpcD8uaWQgfHwgZXZlbnQuZHJhZ0RhdGE/LmNoaXAuaWQ7XG4gICAgICAgIGNvbnN0IGNoaXBzQXJyYXkgPSBhcmVhLmNoaXBzTGlzdC50b0FycmF5KCk7XG4gICAgICAgIGxldCBjaGlwSW5kZXggPSBjaGlwc0FycmF5LmluZGV4T2YoZXZlbnQub3duZXIpICE9PSAtMSA/IGNoaXBzQXJyYXkuaW5kZXhPZihldmVudC5vd25lcikgOiBjaGlwc0FycmF5Lmxlbmd0aDtcbiAgICAgICAgY2hpcEluZGV4ID0gdGhpcy5fZHJvcFBvcyA9PT0gRHJvcFBvc2l0aW9uLkFmdGVyRHJvcFRhcmdldCA/IGNoaXBJbmRleCArIDEgOiBjaGlwSW5kZXg7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzLmZpbmQoeCA9PiB4Lm1lbWJlciA9PT0gZHJhZ0lkIHx8IHguZGlzcGxheU5hbWUgPT09IGRyYWdJZCk7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgZHJhZ0NoaXBJbmRleCA9IGNoaXBzQXJyYXkuaW5kZXhPZihldmVudC5kcmFnQ2hpcCB8fCBldmVudC5kcmFnRGF0YS5jaGlwKTtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5tb3ZlVmFsdWUodmFsdWUsIGRyYWdDaGlwSW5kZXggPj0gY2hpcEluZGV4ID8gY2hpcEluZGV4IDogY2hpcEluZGV4IC0gMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVibGljIG9uRGltRHJvcChldmVudCwgYXJlYSwgZGltZW5zaW9uVHlwZTogUGl2b3REaW1lbnNpb25UeXBlKSB7XG4gICAgICAgIGlmICghKGV2ZW50LmRyYWdDaGlwICYmIGV2ZW50LmRyYWdDaGlwLmRhdGE/LnBpdm90QXJlYSkgJiYgIShldmVudC5kcmFnRGF0YT8uY2hpcCAmJiAhIWV2ZW50LmRyYWdEYXRhLmNoaXAuZGF0YS5waXZvdEFyZWEpKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGRyYWdJZCA9IGV2ZW50LmRyYWdDaGlwPy5pZCB8fCBldmVudC5kcmFnRGF0YT8uY2hpcC5pZDtcbiAgICAgICAgY29uc3QgY3VycmVudERpbSA9IHRoaXMuZ3JpZC5nZXREaW1lbnNpb25zQnlUeXBlKGRpbWVuc2lvblR5cGUpO1xuICAgICAgICBjb25zdCBjaGlwc0FycmF5ID0gYXJlYS5jaGlwc0xpc3QudG9BcnJheSgpO1xuICAgICAgICBjb25zdCBjaGlwID0gY2hpcHNBcnJheS5maW5kKHggPT4geC5pZCA9PT0gZHJhZ0lkKTtcbiAgICAgICAgY29uc3QgaXNOZXdDaGlwID0gY2hpcCA9PT0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBpc1Jlb3JkZXIgPSBldmVudC5vd25lci5pZCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAvL2NvbnN0IGNoaXBJbmRleCA9IGNoaXBzQXJyYXkuaW5kZXhPZihldmVudC5vd25lcikgIT09IC0xID8gY2hpcHNBcnJheS5pbmRleE9mKGV2ZW50Lm93bmVyKSA6IGNoaXBzQXJyYXkubGVuZ3RoO1xuICAgICAgICBjb25zdCBjaGlwSW5kZXggPSBjdXJyZW50RGltLmZpbmRJbmRleCh4ID0+IHgubWVtYmVyTmFtZSA9PT0gZXZlbnQub3duZXIuaWQpICE9PSAtMSA/XG4gICAgICAgICAgICBjdXJyZW50RGltLmZpbmRJbmRleCh4ID0+IHgubWVtYmVyTmFtZSA9PT0gZXZlbnQub3duZXIuaWQpIDogY3VycmVudERpbS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHRhcmdldEluZGV4ID0gdGhpcy5fZHJvcFBvcyA9PT0gRHJvcFBvc2l0aW9uLkFmdGVyRHJvcFRhcmdldCA/IGNoaXBJbmRleCArIDEgOiBjaGlwSW5kZXg7XG4gICAgICAgIGlmIChpc05ld0NoaXApIHtcbiAgICAgICAgICAgIC8vIGNoaXAgbW92ZWQgZnJvbSBhbiBleHRlcm5hbCBjb2xsZWN0aW9uXG4gICAgICAgICAgICBjb25zdCBkaW0gPSB0aGlzLmdyaWQuYWxsRGltZW5zaW9ucy5maW5kKHggPT4geCAmJiB4Lm1lbWJlck5hbWUgPT09IGRyYWdJZCk7XG4gICAgICAgICAgICBpZiAoIWRpbSkge1xuICAgICAgICAgICAgICAgIC8vIHlvdSBoYXZlIGRyYWdnZWQgc29tZXRoaW5nIHRoYXQgaXMgbm90IGEgZGltZW5zaW9uXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ncmlkLm1vdmVEaW1lbnNpb24oZGltLCBkaW1lbnNpb25UeXBlLCB0YXJnZXRJbmRleCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNSZW9yZGVyKSB7XG4gICAgICAgICAgICAvLyBjaGlwIGZyb20gc2FtZSBjb2xsZWN0aW9uLCByZW9yZGVyZWQuXG4gICAgICAgICAgICBjb25zdCBuZXdEaW0gPSBjdXJyZW50RGltLmZpbmQoeCA9PiB4Lm1lbWJlck5hbWUgPT09IGRyYWdJZCk7XG4gICAgICAgICAgICBjb25zdCBkcmFnQ2hpcEluZGV4ID0gY3VycmVudERpbS5maW5kSW5kZXgoeCA9PiB4Lm1lbWJlck5hbWUgPT09IGRyYWdJZCk7XG4gICAgICAgICAgICB0aGlzLmdyaWQubW92ZURpbWVuc2lvbihuZXdEaW0sIGRpbWVuc2lvblR5cGUsIGRyYWdDaGlwSW5kZXggPiBjaGlwSW5kZXggPyB0YXJnZXRJbmRleCA6IHRhcmdldEluZGV4IC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ncmlkLnBpcGVUcmlnZ2VyKys7XG4gICAgICAgIHRoaXMuZ3JpZC5kaW1lbnNpb25zQ2hhbmdlLmVtaXQoeyBkaW1lbnNpb25zOiBjdXJyZW50RGltLCBkaW1lbnNpb25Db2xsZWN0aW9uVHlwZTogZGltZW5zaW9uVHlwZSB9KTtcbiAgICAgICAgLy8gY2xlYW4gc3RhdGVzXG4gICAgICAgIHRoaXMub25EaW1EcmFnRW5kKCk7XG4gICAgICAgIHRoaXMub25BcmVhRHJhZ0xlYXZlKGV2ZW50LCBhcmVhKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgdXBkYXRlRHJvcERvd24odmFsdWU6IElQaXZvdFZhbHVlLCBkcm9wZG93bjogSWd4RHJvcERvd25Db21wb25lbnQsIGNoaXA6IElneENoaXBDb21wb25lbnQpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBkcm9wZG93bi53aWR0aCA9IGNoaXAubmF0aXZlRWxlbWVudC5jbGllbnRXaWR0aCArICdweCc7XG4gICAgICAgIHRoaXMuYWdncmVnYXRlTGlzdCA9IFBpdm90VXRpbC5nZXRBZ2dyZWdhdGVMaXN0KHZhbHVlLCB0aGlzLmdyaWQpO1xuICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIGRyb3Bkb3duLm9wZW4odGhpcy5fc3ViTWVudU92ZXJsYXlTZXR0aW5ncyk7XG4gICAgfVxufVxuIiwiPGRpdj5cbiAgICA8ZGl2IGNsYXNzPVwiaWd4LWdyaWQtdGhlYWRfX3dyYXBwZXIgaWd4LWdyaWQtdGhlYWRfX3dyYXBwZXItLXBpdm90XCIgcm9sZT1cInJvd1wiIFtzdHlsZS53aWR0aC5weF09XCJ3aWR0aFwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX3RyXCIgcm9sZT1cInJvd1wiIFtzdHlsZS53aWR0aC5weF09XCJ3aWR0aFwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz0naWd4LWdyaWRfX3RyLXBpdm90LS1maWx0ZXItY29udGFpbmVyJz5cbiAgICAgICAgICAgICAgICA8ZGl2ICNwaXZvdEZpbHRlckNvbnRhaW5lciAqbmdJZj1cImdyaWQuc2hvd1Bpdm90Q29uZmlndXJhdGlvblVJXCJcbiAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiaWd4LWdyaWRfX3RyLXBpdm90IGlneC1ncmlkX190ci1waXZvdC0tZmlsdGVyXCIgW3N0eWxlLm1pbi13aWR0aC5weF09XCJncmlkLnBpdm90Um93V2lkdGhzIC0gMVwiXG4gICAgICAgICAgICAgICAgICAgICBbc3R5bGUubWF4LXdpZHRoLnB4XT1cImdyaWQucGl2b3RSb3dXaWR0aHMgLSAxXCIgKGlneERyYWdMZWF2ZSk9XCJvbkFyZWFEcmFnTGVhdmUoJGV2ZW50LCBmaWx0ZXJBcmVhKVwiXG4gICAgICAgICAgICAgICAgICAgICBpZ3hEcm9wIChkcm9wcGVkKT1cIm9uRGltRHJvcCgkZXZlbnQsIGZpbHRlckFyZWEsIDIpXCIgKHBvaW50ZXJkb3duKT1cIiRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCI+XG4gICAgICAgICAgICAgICAgICAgIDwhLS0gRmlsdGVyIGFyZWEgLS0+XG4gICAgICAgICAgICAgICAgICAgIDxpZ3gtY2hpcHMtYXJlYSAjZmlsdGVyQXJlYSBkcm9wcGFibGU9J3RydWUnPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBpZD0nZW1wdHknIGlneERyb3AgKGRyb3BwZWQpPVwib25EaW1Ecm9wKCRldmVudCwgZmlsdGVyQXJlYSwgMilcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAqbmdJZj1cImdyaWQuZmlsdGVyRGltZW5zaW9ucy5sZW5ndGggPT09IDBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz0naWd4LWdyaWRfX3Bpdm90LWVtcHR5LWNoaXAtYXJlYSc+e3tncmlkLnJlc291cmNlU3RyaW5ncy5pZ3hfZ3JpZF9waXZvdF9lbXB0eV9maWx0ZXJfZHJvcF9hcmVhfX08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCBmaWx0ZXIgb2YgdGhpcy5maWx0ZXJBcmVhRGltZW5zaW9uczsgbGV0IGxhc3QgPSBsYXN0O1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gW3N0eWxlLnZpc2liaWxpdHldPSdcImhpZGRlblwiJyBjbGFzcz1cImlneC1ncmlkX190ci1waXZvdC0tY2hpcF9kcm9wX2luZGljYXRvclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3R5bGUuaGVpZ2h0LnB4XT0nZ2V0QXJlYUhlaWdodChmaWx0ZXJBcmVhKSc+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpZ3gtY2hpcCBbaWRdPVwiZmlsdGVyLm1lbWJlck5hbWVcIiBbZHJhZ2dhYmxlXT1cInRydWVcIiBbZGlzcGxheURlbnNpdHldPVwiZ3JpZC5kaXNwbGF5RGVuc2l0eVwiIFtkYXRhXT1cInsgcGl2b3RBcmVhOiAnZmlsdGVyJyB9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3JlbW92YWJsZV09XCJ0cnVlXCIgKHJlbW92ZSk9XCJmaWx0ZXJSZW1vdmVkKCRldmVudClcIiAoZHJhZ092ZXIpPVwib25EaW1EcmFnT3ZlcigkZXZlbnQsIDIpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRyYWdMZWF2ZSk9XCJvbkRpbURyYWdMZWF2ZSgkZXZlbnQpXCIgKGRyYWdEcm9wKT1cIm9uRGltRHJvcCgkZXZlbnQsIGZpbHRlckFyZWEsIDIpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1vdmVTdGFydCk9J29uRGltRHJhZ1N0YXJ0KCRldmVudCwgZmlsdGVyQXJlYSknIChtb3ZlRW5kKT0nb25EaW1EcmFnRW5kKCknPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aWd4LWljb24gaWd4UHJlZml4IChwb2ludGVyZG93bik9J29uRmlsdGVyaW5nSWNvblBvaW50ZXJEb3duKCRldmVudCknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY2xpY2spPSdvbkZpbHRlcmluZ0ljb25DbGljaygkZXZlbnQsIGZpbHRlciknPmZpbHRlcl9saXN0PC9pZ3gtaWNvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3tmaWx0ZXIubWVtYmVyTmFtZX19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9pZ3gtY2hpcD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPSdsYXN0Jz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBbc3R5bGUudmlzaWJpbGl0eV09J1wiaGlkZGVuXCInIGNsYXNzPVwiaWd4LWdyaWRfX3RyLXBpdm90LS1jaGlwX2Ryb3BfaW5kaWNhdG9yXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3R5bGUuaGVpZ2h0LnB4XT0nZ2V0QXJlYUhlaWdodChmaWx0ZXJBcmVhKSc+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aWd4LWNoaXAgaWd4RHJvcCAoZHJhZ0Ryb3ApPVwib25EaW1Ecm9wKCRldmVudCwgZmlsdGVyQXJlYSwgMilcIiAjbm90aWZ5Q2hpcCBbaGlkZGVuXT0ndHJ1ZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZGlzcGxheURlbnNpdHldPVwiZ3JpZC5kaXNwbGF5RGVuc2l0eVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7Z3JpZC5yZXNvdXJjZVN0cmluZ3MuaWd4X2dyaWRfcGl2b3RfZmlsdGVyX2Ryb3BfY2hpcH19XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2lneC1jaGlwPlxuICAgICAgICAgICAgICAgICAgICA8L2lneC1jaGlwcy1hcmVhPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX3Bpdm90LWZpbHRlci10b2dnbGVcIiAqbmdJZj1cImlzRmlsdGVyc0J1dHRvbiAmJiBncmlkLmZpbHRlckRpbWVuc2lvbnMubGVuZ3RoICE9PSAwXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aWd4LWljb24gI2ZpbHRlckljb24gKHBvaW50ZXJkb3duKT0nb25GaWx0ZXJpbmdJY29uUG9pbnRlckRvd24oJGV2ZW50KScgKGNsaWNrKT0nb25GaWx0ZXJzQXJlYURyb3Bkb3duQ2xpY2soJGV2ZW50KSc+ZmlsdGVyX2xpc3Q8L2lneC1pY29uPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGlneC1iYWRnZSB2YWx1ZT1cInt7dGhpcy5maWx0ZXJEcm9wZG93bkRpbWVuc2lvbnMuc2l6ZX19XCI+PC9pZ3gtYmFkZ2U+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9J2lneC1ncmlkX190ci1waXZvdC0tZHJvcC1yb3ctYXJlYScgKGlneERyYWdMZWF2ZSk9XCJvbkFyZWFEcmFnTGVhdmUoJGV2ZW50LCByb3dBcmVhKVwiIGlneERyb3BcbiAgICAgICAgICAgICAgICAgICAgIChkcm9wcGVkKT1cIm9uRGltRHJvcCgkZXZlbnQsIHJvd0FyZWEsIDApXCI+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImlneC1ncmlkX190ci1waXZvdC1ncm91cFwiPlxuICAgICAgICAgICAgICAgIDxkaXYgI3Bpdm90Q29sdW1uQ29udGFpbmVyICpuZ0lmPVwiZ3JpZC5zaG93UGl2b3RDb25maWd1cmF0aW9uVUlcIiBjbGFzcz1cImlneC1ncmlkX190ci1waXZvdFwiXG4gICAgICAgICAgICAgICAgICAgICAoZHJvcHBlZCk9XCJvbkRpbURyb3AoJGV2ZW50LCBjb2xBcmVhLCAxKVwiIGlneERyb3AgKGlneERyYWdMZWF2ZSk9XCJvbkFyZWFEcmFnTGVhdmUoJGV2ZW50LCBjb2xBcmVhKVwiPlxuICAgICAgICAgICAgICAgICAgICA8IS0tIENvbHVtbnMgYXJlYSAtLT5cbiAgICAgICAgICAgICAgICAgICAgPGlneC1jaGlwcy1hcmVhICNjb2xBcmVhIGRyb3BwYWJsZT0ndHJ1ZSc+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGlkPSdlbXB0eScgKGRyb3BwZWQpPVwib25EaW1Ecm9wKCRldmVudCwgY29sQXJlYSwgMSlcIiBpZ3hEcm9wXG4gICAgICAgICAgICAgICAgICAgICAgICAqbmdJZj1cImdyaWQuY29sdW1uRGltZW5zaW9ucy5sZW5ndGggPT09IDBcIiBjbGFzcz0naWd4LWdyaWRfX3Bpdm90LWVtcHR5LWNoaXAtYXJlYSc+XG4gICAgICAgICAgICAgICAgICAgICAgICB7e2dyaWQucmVzb3VyY2VTdHJpbmdzLmlneF9ncmlkX3Bpdm90X2VtcHR5X2NvbHVtbl9kcm9wX2FyZWF9fTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGNvbCBvZiBncmlkLmNvbHVtbkRpbWVuc2lvbnM7IGxldCBsYXN0ID0gbGFzdDtcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIFtzdHlsZS52aXNpYmlsaXR5XT0nXCJoaWRkZW5cIicgY2xhc3M9XCJpZ3gtZ3JpZF9fdHItcGl2b3QtLWNoaXBfZHJvcF9pbmRpY2F0b3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0eWxlLmhlaWdodC5weF09J2dldEFyZWFIZWlnaHQoY29sQXJlYSknPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aWd4LWNoaXAgW2RyYWdnYWJsZV09XCJ0cnVlXCIgW2lkXT1cImNvbC5tZW1iZXJOYW1lXCIgW2Rpc3BsYXlEZW5zaXR5XT1cImdyaWQuZGlzcGxheURlbnNpdHlcIiBbZGF0YV09XCJ7IHBpdm90QXJlYTogJ2NvbHVtbicgfVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtyZW1vdmFibGVdPVwidHJ1ZVwiIChyZW1vdmUpPVwiY29sdW1uUmVtb3ZlZCgkZXZlbnQpXCIgKGRyYWdPdmVyKT1cIm9uRGltRHJhZ092ZXIoJGV2ZW50LCAxKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkcmFnTGVhdmUpPVwib25EaW1EcmFnTGVhdmUoJGV2ZW50KVwiIChkcmFnRHJvcCk9XCJvbkRpbURyb3AoJGV2ZW50LCBjb2xBcmVhLCAxKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtb3ZlU3RhcnQpPSdvbkRpbURyYWdTdGFydCgkZXZlbnQsIGNvbEFyZWEpJyAobW92ZUVuZCk9J29uRGltRHJhZ0VuZCgpJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVwib25DaGlwU29ydCgkZXZlbnQsIGNvbClcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlneC1pY29uIGlneFByZWZpeD52aWV3X2NvbHVtbjwvaWd4LWljb24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpZ3gtaWNvbiBpZ3hQcmVmaXggKHBvaW50ZXJkb3duKT0nb25GaWx0ZXJpbmdJY29uUG9pbnRlckRvd24oJGV2ZW50KSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjbGljayk9J29uRmlsdGVyaW5nSWNvbkNsaWNrKCRldmVudCwgY29sKSc+ZmlsdGVyX2xpc3Q8L2lneC1pY29uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7e2NvbC5tZW1iZXJOYW1lfX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlneC1pY29uICpuZ0lmPVwiY29sLnNvcnREaXJlY3Rpb25cIiBpZ3hTdWZmaXg+IHt7IGNvbC5zb3J0RGlyZWN0aW9uIDwgMiA/ICdhcnJvd191cHdhcmQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdhcnJvd19kb3dud2FyZCcgfX08L2lneC1pY29uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvaWd4LWNoaXA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj0nbGFzdCc+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gW3N0eWxlLnZpc2liaWxpdHldPSdcImhpZGRlblwiJyBjbGFzcz1cImlneC1ncmlkX190ci1waXZvdC0tY2hpcF9kcm9wX2luZGljYXRvclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0eWxlLmhlaWdodC5weF09J2dldEFyZWFIZWlnaHQoY29sQXJlYSknPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGlneC1jaGlwIGlneERyb3AgKGRyYWdEcm9wKT1cIm9uRGltRHJvcCgkZXZlbnQsIGNvbEFyZWEsIDEpXCIgI25vdGlmeUNoaXAgW2hpZGRlbl09J3RydWUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2Rpc3BsYXlEZW5zaXR5XT1cImdyaWQuZGlzcGxheURlbnNpdHlcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7e2dyaWQucmVzb3VyY2VTdHJpbmdzLmlneF9ncmlkX3Bpdm90X2NvbHVtbl9kcm9wX2NoaXB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9pZ3gtY2hpcD5cbiAgICAgICAgICAgICAgICAgICAgPC9pZ3gtY2hpcHMtYXJlYT5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICAgIDxkaXYgI3Bpdm90VmFsdWVDb250YWluZXIgKm5nSWY9XCJncmlkLnNob3dQaXZvdENvbmZpZ3VyYXRpb25VSVwiIGNsYXNzPVwiaWd4LWdyaWRfX3RyLXBpdm90XCJcbiAgICAgICAgICAgICAgICAgICAgIChwb2ludGVyZG93bik9XCIkZXZlbnQucHJldmVudERlZmF1bHQoKVwiIChkcm9wcGVkKT1cIm9uVmFsdWVEcm9wKCRldmVudCwgdmFsdWVBcmVhKVwiIGlneERyb3BcbiAgICAgICAgICAgICAgICAgICAgIChpZ3hEcmFnTGVhdmUpPVwib25BcmVhRHJhZ0xlYXZlKCRldmVudCwgdmFsdWVBcmVhKVwiPlxuICAgICAgICAgICAgICAgICAgICA8IS0tIFZhbHVlIGFyZWEgLS0+XG4gICAgICAgICAgICAgICAgICAgIDxpZ3gtY2hpcHMtYXJlYSAjdmFsdWVBcmVhIGRyb3BwYWJsZT0ndHJ1ZSc+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGlkPSdlbXB0eScgKGRyb3BwZWQpPVwib25WYWx1ZURyb3AoJGV2ZW50LCB2YWx1ZUFyZWEpXCIgaWd4RHJvcCAqbmdJZj1cImdyaWQudmFsdWVzLmxlbmd0aCA9PT0gMFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz0naWd4LWdyaWRfX3Bpdm90LWVtcHR5LWNoaXAtYXJlYSc+e3tncmlkLnJlc291cmNlU3RyaW5ncy5pZ3hfZ3JpZF9waXZvdF9lbXB0eV92YWx1ZV9kcm9wX2FyZWF9fTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgdmFsdWUgb2YgZ3JpZC52YWx1ZXM7IGxldCBsYXN0ID0gbGFzdDtcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIFtzdHlsZS52aXNpYmlsaXR5XT0nXCJoaWRkZW5cIicgY2xhc3M9XCJpZ3gtZ3JpZF9fdHItcGl2b3QtLWNoaXBfZHJvcF9pbmRpY2F0b3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0eWxlLmhlaWdodC5weF09J2dldEFyZWFIZWlnaHQodmFsdWVBcmVhKSc+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpZ3gtY2hpcCAjY3VyckNoaXAgW2RyYWdnYWJsZV09XCJ0cnVlXCIgW2lkXT1cInZhbHVlLmRpc3BsYXlOYW1lIHx8IHZhbHVlLm1lbWJlclwiIFtkYXRhXT1cInsgcGl2b3RBcmVhOiAndmFsdWUnIH1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZGlzcGxheURlbnNpdHldPVwiZ3JpZC5kaXNwbGF5RGVuc2l0eVwiIFtyZW1vdmFibGVdPVwidHJ1ZVwiIChyZW1vdmUpPVwidmFsdWVSZW1vdmVkKCRldmVudClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZHJhZ0xlYXZlKT1cIm9uRGltRHJhZ0xlYXZlKCRldmVudClcIiAoZHJhZ092ZXIpPVwib25EaW1EcmFnT3ZlcigkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRyYWdEcm9wKT1cIm9uVmFsdWVEcm9wKCRldmVudCwgdmFsdWVBcmVhKVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX3RyLXBpdm90LXRvZ2dsZS1pY29uc1wiIGlneFByZWZpeFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjbGljayk9J29uU3VtbWFyeUNsaWNrKCRldmVudCwgdmFsdWUsIGRyb3Bkb3duLCBjdXJyQ2hpcCknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHBvaW50ZXJkb3duKT0nJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpJyBbaWd4RHJvcERvd25JdGVtTmF2aWdhdGlvbl09XCJkcm9wZG93blwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlneC1pY29uPmZ1bmN0aW9uczwvaWd4LWljb24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aWd4LWljb24+YXJyb3dfZHJvcF9kb3duPC9pZ3gtaWNvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7dmFsdWUuYWdncmVnYXRlLmtleX19KHt7dmFsdWUuZGlzcGxheU5hbWUgfHwgdmFsdWUubWVtYmVyfX0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9pZ3gtY2hpcD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPSdsYXN0Jz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBbc3R5bGUudmlzaWJpbGl0eV09J1wiaGlkZGVuXCInIGNsYXNzPVwiaWd4LWdyaWRfX3RyLXBpdm90LS1jaGlwX2Ryb3BfaW5kaWNhdG9yXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3R5bGUuaGVpZ2h0LnB4XT0nZ2V0QXJlYUhlaWdodCh2YWx1ZUFyZWEpJz48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpZ3gtY2hpcCBpZ3hEcm9wIChkcmFnRHJvcCk9XCJvblZhbHVlRHJvcCgkZXZlbnQsIHZhbHVlQXJlYSlcIiAjbm90aWZ5VmFsdWVDaGlwIFtoaWRkZW5dPSd0cnVlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtkaXNwbGF5RGVuc2l0eV09XCJncmlkLmRpc3BsYXlEZW5zaXR5XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3tncmlkLnJlc291cmNlU3RyaW5ncy5pZ3hfZ3JpZF9waXZvdF92YWx1ZV9kcm9wX2NoaXB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9pZ3gtY2hpcD5cbiAgICAgICAgICAgICAgICAgICAgPC9pZ3gtY2hpcHMtYXJlYT5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IHJvbGU9XCJyb3dncm91cFwiIGNsYXNzPVwiaWd4LWdyaWQtdGhlYWRfX3dyYXBwZXJcIiBbc3R5bGUud2lkdGgucHhdPVwid2lkdGhcIlxuICAgICAgICAgW2F0dHIuYXJpYS1hY3RpdmVkZXNjZW5kYW50XT1cImFjdGl2ZURlc2NlbmRhbnRcIiBbY2xhc3MuaWd4LWdyaWRfX3RyLS1tcmxdPVwiaGFzTVJMXCI+XG5cbiAgICAgICAgPCEtLSBDb2x1bW4gaGVhZGVycyBhcmVhIC0tPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX3RyXCIgcm9sZT1cInJvd1wiIFtzdHlsZS53aWR0aC5weF09XCJ3aWR0aFwiPlxuICAgICAgICAgICAgPGRpdiAjcGl2b3RDb250YWluZXIgY2xhc3M9XCJpZ3gtZ3JpZF9fdHItcGl2b3QgaWd4LWdyaWRfX3RyLXBpdm90LS1yb3ctYXJlYVwiXG4gICAgICAgICAgICAgICAgIFtzdHlsZS53aWR0aC5weF09XCJncmlkLnBpdm90Um93V2lkdGhzIC0gMVwiIChpZ3hEcmFnTGVhdmUpPVwib25BcmVhRHJhZ0xlYXZlKCRldmVudCwgcm93QXJlYSlcIiBpZ3hEcm9wXG4gICAgICAgICAgICAgICAgIChkcm9wcGVkKT1cIm9uRGltRHJvcCgkZXZlbnQsIHJvd0FyZWEsIDApXCIgKHBvaW50ZXJkb3duKT1cIiRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCI+XG4gICAgICAgICAgICAgICAgPCEtLSBSb3cgYXJlYSAtLT5cbiAgICAgICAgICAgICAgICA8aWd4LWNoaXBzLWFyZWEgI3Jvd0FyZWEgZHJvcHBhYmxlPSd0cnVlJz5cbiAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cImdyaWQuc2hvd1Bpdm90Q29uZmlndXJhdGlvblVJXCI+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGlkPSdlbXB0eScgaWd4RHJvcCAoZHJvcHBlZCk9XCJvbkRpbURyb3AoJGV2ZW50LCByb3dBcmVhLCAwKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAqbmdJZj1cImdyaWQucm93RGltZW5zaW9ucy5sZW5ndGggPT09IDAgJiYgZ3JpZC5zaG93UGl2b3RDb25maWd1cmF0aW9uVUlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9J2lneC1ncmlkX19waXZvdC1lbXB0eS1jaGlwLWFyZWEnPnt7Z3JpZC5yZXNvdXJjZVN0cmluZ3MuaWd4X2dyaWRfcGl2b3RfZW1wdHlfcm93X2Ryb3BfYXJlYX19PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCByb3cgb2YgZ3JpZC5yb3dEaW1lbnNpb25zOyBsZXQgbGFzdCA9IGxhc3Q7XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBbc3R5bGUudmlzaWJpbGl0eV09J1wiaGlkZGVuXCInIGNsYXNzPVwiaWd4LWdyaWRfX3RyLXBpdm90LS1jaGlwX2Ryb3BfaW5kaWNhdG9yXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHlsZS5oZWlnaHQucHhdPSdnZXRBcmVhSGVpZ2h0KHJvd0FyZWEpJz48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlneC1jaGlwIFtkcmFnZ2FibGVdPVwidHJ1ZVwiIFtpZF09XCJyb3cubWVtYmVyTmFtZVwiIFtkaXNwbGF5RGVuc2l0eV09XCJncmlkLmRpc3BsYXlEZW5zaXR5XCIgW2RhdGFdPVwieyBwaXZvdEFyZWE6ICdyb3cnIH1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbcmVtb3ZhYmxlXT1cInRydWVcIiAocmVtb3ZlKT1cInJvd1JlbW92ZWQoJGV2ZW50KVwiIChkcmFnTGVhdmUpPVwib25EaW1EcmFnTGVhdmUoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkcmFnRHJvcCk9XCJvbkRpbURyb3AoJGV2ZW50LCByb3dBcmVhLCAwKVwiIChkcmFnT3Zlcik9XCJvbkRpbURyYWdPdmVyKCRldmVudCwgMClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobW92ZVN0YXJ0KT0nb25EaW1EcmFnU3RhcnQoJGV2ZW50LCByb3dBcmVhKScgKG1vdmVFbmQpPSdvbkRpbURyYWdFbmQoKSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cIm9uQ2hpcFNvcnQoJGV2ZW50LCByb3cpXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpZ3gtaWNvbiBpZ3hQcmVmaXg+dGFibGVfcm93czwvaWd4LWljb24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpZ3gtaWNvbiBpZ3hQcmVmaXggKHBvaW50ZXJkb3duKT0nb25GaWx0ZXJpbmdJY29uUG9pbnRlckRvd24oJGV2ZW50KSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjbGljayk9J29uRmlsdGVyaW5nSWNvbkNsaWNrKCRldmVudCwgcm93KSc+ZmlsdGVyX2xpc3Q8L2lneC1pY29uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7eyByb3cubWVtYmVyTmFtZX19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpZ3gtaWNvbiAqbmdJZj1cInJvdy5zb3J0RGlyZWN0aW9uXCIgaWd4U3VmZml4PiB7eyByb3cuc29ydERpcmVjdGlvbiA8IDIgPyAnYXJyb3dfdXB3YXJkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnYXJyb3dfZG93bndhcmQnIH19PC9pZ3gtaWNvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2lneC1jaGlwPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9J2xhc3QnPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIFtzdHlsZS52aXNpYmlsaXR5XT0nXCJoaWRkZW5cIicgY2xhc3M9XCJpZ3gtZ3JpZF9fdHItcGl2b3QtLWNoaXBfZHJvcF9pbmRpY2F0b3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHlsZS5oZWlnaHQucHhdPSdnZXRBcmVhSGVpZ2h0KHJvd0FyZWEpJz48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpZ3gtY2hpcCBpZ3hEcm9wIChkcmFnRHJvcCk9XCJvbkRpbURyb3AoJGV2ZW50LCByb3dBcmVhLCAwKVwiICNub3RpZnlDaGlwIFtoaWRkZW5dPSd0cnVlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtkaXNwbGF5RGVuc2l0eV09XCJncmlkLmRpc3BsYXlEZW5zaXR5XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3tncmlkLnJlc291cmNlU3RyaW5ncy5pZ3hfZ3JpZF9waXZvdF9yb3dfZHJvcF9jaGlwfX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvaWd4LWNoaXA+XG4gICAgICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgIDwvaWd4LWNoaXBzLWFyZWE+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPCEtLSBQaW5uZWQgY29sdW1ucyBjb2xsZWN0aW9uIGZyb20gdGhlIHN0YXJ0IC0tPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cInBpbm5lZENvbHVtbkNvbGxlY3Rpb24ubGVuZ3RoICYmIGdyaWQuaXNQaW5uaW5nVG9TdGFydFwiPlxuICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGNvbHVtbiBvZiBwaW5uZWRDb2x1bW5Db2xsZWN0aW9uIHwgaWd4VG9wTGV2ZWxcIj5cbiAgICAgICAgICAgICAgICAgICAgPGlneC1ncmlkLWhlYWRlci1ncm91cCBbbmdDbGFzc109XCJjb2x1bW4uaGVhZGVyR3JvdXBDbGFzc2VzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbmdTdHlsZV09XCJjb2x1bW4uaGVhZGVyR3JvdXBTdHlsZXMgfCBpZ3hIZWFkZXJHcm91cFN0eWxlOmNvbHVtbjpncmlkLnBpcGVUcmlnZ2VyXCIgW2NvbHVtbl09XCJjb2x1bW5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHlsZS5taW4td2lkdGhdPVwiY29sdW1uLmNhbGNXaWR0aCB8IGlneEhlYWRlckdyb3VwV2lkdGg6Z3JpZC5kZWZhdWx0SGVhZGVyR3JvdXBNaW5XaWR0aDpoYXNNUkxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHlsZS5mbGV4LWJhc2lzXT1cImNvbHVtbi5jYWxjV2lkdGggfCBpZ3hIZWFkZXJHcm91cFdpZHRoOmdyaWQuZGVmYXVsdEhlYWRlckdyb3VwTWluV2lkdGg6aGFzTVJMXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocG9pbnRlcmRvd24pPVwiZ3JpZC5uYXZpZ2F0aW9uLmZvY3VzT3V0Um93SGVhZGVyKCRldmVudClcIj5cbiAgICAgICAgICAgICAgICAgICAgPC9pZ3gtZ3JpZC1oZWFkZXItZ3JvdXA+XG4gICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpZ3gtZ3JpZC10aGVhZC0tdmlydHVhbGl6YXRpb25XcmFwcGVyXCIgW3N0eWxlLm1heC1oZWlnaHQucHhdPSdtYXhDb250YWluZXJIZWlnaHQnPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpZ3gtZ3JpZC10aGVhZF9fZ3JvdXAgaWd4LWdyaWQtdGhlYWQtLXZpcnR1YWxpemF0aW9uQ29udGFpbmVyXCIgW3N0eWxlLmhlaWdodC5weF09J3RvdGFsRGVwdGggPiAxID8gZ3JpZC5yb3dIZWlnaHQgOiB1bmRlZmluZWQnICpuZ0Zvcj0nbGV0IGRpbUxldmVsQ29sdW1ucyBvZiBjb2x1bW5EaW1lbnNpb25zQnlMZXZlbDsgbGV0IGkgPSBpbmRleCcgW3N0eWxlLndpZHRoLnB4XT0nZ3JpZC51bnBpbm5lZFdpZHRoJz5cbiAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIGlneEdyaWRGb3IgI2hlYWRlclZpcnR1YWxDb250YWluZXIgbGV0LWNvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2lneEdyaWRGb3JPZl09XCJkaW1MZXZlbENvbHVtbnNcIiBbaWd4R3JpZEZvck9mVW5pcXVlU2l6ZUNhY2hlXSA9ICd0cnVlJyBbaWd4Rm9yU2Nyb2xsQ29udGFpbmVyXT1cImdyaWQucGFyZW50VmlydERpclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbaWd4Rm9yQ29udGFpbmVyU2l6ZV09XCJncmlkLnVucGlubmVkV2lkdGhcIiBbaWd4Rm9yVHJhY2tCeV09XCJncmlkLnRyYWNrQ29sdW1uQ2hhbmdlc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbaWd4Rm9yU2l6ZVByb3BOYW1lXT1cIidjYWxjUGl4ZWxXaWR0aCdcIiBbaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb25dPVwiJ2hvcml6b250YWwnXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aWd4LWdyaWQtaGVhZGVyLWdyb3VwIFtuZ0NsYXNzXT1cImNvbHVtbi5oZWFkZXJHcm91cENsYXNzZXNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3R5bGUuaGVpZ2h0LnB4XT0ndG90YWxEZXB0aCA+IDEgPyBjYWxjSGVpZ2h0KGNvbHVtbiwgaSkgOiB1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1N0eWxlXT1cImNvbHVtbi5oZWFkZXJHcm91cFN0eWxlcyB8aWd4SGVhZGVyR3JvdXBTdHlsZTpjb2x1bW46Z3JpZC5waXBlVHJpZ2dlclwiIFtjb2x1bW5dPVwiY29sdW1uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0eWxlLm1pbi13aWR0aF09XCJjb2x1bW4uY2FsY1dpZHRoIHwgaWd4SGVhZGVyR3JvdXBXaWR0aDpncmlkLmRlZmF1bHRIZWFkZXJHcm91cE1pbldpZHRoOmhhc01STFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHlsZS5mbGV4LWJhc2lzXT1cImNvbHVtbi5jYWxjV2lkdGggfCBpZ3hIZWFkZXJHcm91cFdpZHRoOmdyaWQuZGVmYXVsdEhlYWRlckdyb3VwTWluV2lkdGg6aGFzTVJMXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NsYXNzLmlneC1ncmlkX190ci1waXZvdC0tY29sdW1uRGltZW5zaW9uTGVhZl0gPSAnaXNEdXBsaWNhdGVPZkV4aXN0aW5nUGFyZW50KGNvbHVtbiwgaSknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjbGFzcy5pZ3gtZ3JpZF9fdHItcGl2b3QtLWNvbHVtbk11bHRpUm93U3Bhbl0gPSAnaXNNdWx0aVJvdyhjb2x1bW4sIGkpJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9pZ3gtZ3JpZC1oZWFkZXItZ3JvdXA+XG4gICAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPCEtLSBQaW5uZWQgY29sdW1ucyBjb2xsZWN0aW9uIGF0IHRoZSBlbmQgLS0+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwicGlubmVkQ29sdW1uQ29sbGVjdGlvbi5sZW5ndGggJiYgIWdyaWQuaXNQaW5uaW5nVG9TdGFydFwiPlxuICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGNvbHVtbiBvZiBwaW5uZWRDb2x1bW5Db2xsZWN0aW9uIHwgaWd4VG9wTGV2ZWxcIj5cbiAgICAgICAgICAgICAgICAgICAgPGlneC1ncmlkLWhlYWRlci1ncm91cCBbbmdDbGFzc109XCJjb2x1bW4uaGVhZGVyR3JvdXBDbGFzc2VzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbmdTdHlsZV09XCJjb2x1bW4uaGVhZGVyR3JvdXBTdHlsZXMgfGlneEhlYWRlckdyb3VwU3R5bGU6Y29sdW1uOmdyaWQucGlwZVRyaWdnZXJcIiBbY29sdW1uXT1cImNvbHVtblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0eWxlLm1pbi13aWR0aF09XCJjb2x1bW4uY2FsY1dpZHRoIHwgaWd4SGVhZGVyR3JvdXBXaWR0aDpncmlkLmRlZmF1bHRIZWFkZXJHcm91cE1pbldpZHRoOmhhc01STFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0eWxlLmZsZXgtYmFzaXNdPVwiY29sdW1uLmNhbGNXaWR0aCB8IGlneEhlYWRlckdyb3VwV2lkdGg6Z3JpZC5kZWZhdWx0SGVhZGVyR3JvdXBNaW5XaWR0aDpoYXNNUkxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHlsZS5sZWZ0XT1cImNvbHVtbi5yaWdodFBpbm5lZE9mZnNldFwiIChwb2ludGVyZG93bik9XCJncmlkLm5hdmlnYXRpb24uZm9jdXNPdXRSb3dIZWFkZXIoJGV2ZW50KVwiPlxuICAgICAgICAgICAgICAgICAgICA8L2lneC1ncmlkLWhlYWRlci1ncm91cD5cbiAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuPCEtLSBIZWFkZXIgdGh1bWIgYXJlYSAtLT5cbjxkaXYgY2xhc3M9XCJpZ3gtZ3JpZC10aGVhZF9fdGh1bWJcIiBbaGlkZGVuXT1cIiFncmlkLmhhc1ZlcnRpY2FsU2Nyb2xsKClcIiBbc3R5bGUud2lkdGgucHhdPVwiZ3JpZC5zY3JvbGxTaXplXCI+XG48L2Rpdj5cblxuPGlneC1kcm9wLWRvd24gI2Ryb3Bkb3duIChzZWxlY3Rpb25DaGFuZ2luZyk9J29uQWdncmVnYXRpb25DaGFuZ2UoJGV2ZW50KSc+XG4gICAgPGlneC1kcm9wLWRvd24taXRlbSAqbmdGb3I9XCJsZXQgaXRlbSBvZiBhZ2dyZWdhdGVMaXN0XCIgW3NlbGVjdGVkXT0naXNTZWxlY3RlZChpdGVtKScgW3ZhbHVlXT0naXRlbSc+XG4gICAgICAgIHt7IGl0ZW0ubGFiZWwgfX1cbiAgICA8L2lneC1kcm9wLWRvd24taXRlbT5cbjwvaWd4LWRyb3AtZG93bj5cblxuPGRpdiBbaGlkZGVuXT0ndHJ1ZSc+XG4gICAgPGlneC1ncmlkLWV4Y2VsLXN0eWxlLWZpbHRlcmluZyBbbWF4SGVpZ2h0XT0nZ3JpZC5leGNlbFN0eWxlRmlsdGVyTWF4SGVpZ2h0JyBbbWluSGVpZ2h0XT0nZ3JpZC5leGNlbFN0eWxlRmlsdGVyTWluSGVpZ2h0JyAjZXNmPlxuICAgICAgICA8ZGl2IGlneEV4Y2VsU3R5bGVDb2x1bW5PcGVyYXRpb25zPlxuICAgICAgICAgICAgPGlneC1jaGlwcy1hcmVhICNkcm9wZG93bkNoaXBzPlxuICAgICAgICAgICAgICAgIDxpZ3gtY2hpcCAqbmdGb3I9XCJsZXQgZmlsdGVyIG9mIHRoaXMuZmlsdGVyRHJvcGRvd25EaW1lbnNpb25zXCIgW2lkXT1cImZpbHRlci5tZW1iZXJOYW1lXCJcbiAgICAgICAgICAgICAgICBbZGlzcGxheURlbnNpdHldPVwiZ3JpZC5kaXNwbGF5RGVuc2l0eVwiIFtyZW1vdmFibGVdPVwidHJ1ZVwiIChyZW1vdmUpPVwiZmlsdGVyUmVtb3ZlZCgkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAoY2hpcENsaWNrKT0nb25GaWx0ZXJzU2VsZWN0aW9uQ2hhbmdlZCgkZXZlbnQpJyBbc2VsZWN0YWJsZV09J3RydWUnIFtzZWxlY3RlZF09J2ZpbHRlciA9PT0gdGhpcy5maWx0ZXJEcm9wZG93bkRpbWVuc2lvbnMudmFsdWVzKCkubmV4dCgpLnZhbHVlJz5cbiAgICAgICAgICAgICAgICB7e2ZpbHRlci5tZW1iZXJOYW1lfX1cbiAgICAgICAgICAgIDwvaWd4LWNoaXA+XG4gICAgICAgIDwvaWd4LWNoaXBzLWFyZWE+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8aWd4LWV4Y2VsLXN0eWxlLWZpbHRlci1vcGVyYXRpb25zPlxuICAgICAgICAgICAgPGlneC1leGNlbC1zdHlsZS1zZWFyY2g+PC9pZ3gtZXhjZWwtc3R5bGUtc2VhcmNoPlxuICAgICAgICA8L2lneC1leGNlbC1zdHlsZS1maWx0ZXItb3BlcmF0aW9ucz5cbiAgICA8L2lneC1ncmlkLWV4Y2VsLXN0eWxlLWZpbHRlcmluZz5cbjwvZGl2PlxuXG48ZGl2IHN0eWxlPVwidmlzaWJpbGl0eTogaGlkZGVuOyBwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogLTEwMDAwcHhcIj5cbiAgICA8aWd4LWNoaXBzLWFyZWEgI2ZpbHRlckFyZWFIaWRkZW4gZHJvcHBhYmxlPSd0cnVlJz5cbiAgICAgICAgPGlneC1jaGlwICpuZ0Zvcj1cImxldCBmaWx0ZXIgb2YgZ3JpZC5maWx0ZXJEaW1lbnNpb25zXCIgW2lkXT1cImZpbHRlci5tZW1iZXJOYW1lXCIgW2RyYWdnYWJsZV09XCJ0cnVlXCJcbiAgICAgICAgICAgIFtkaXNwbGF5RGVuc2l0eV09XCJncmlkLmRpc3BsYXlEZW5zaXR5XCIgW3JlbW92YWJsZV09XCJ0cnVlXCIgKHJlbW92ZSk9XCJmaWx0ZXJSZW1vdmVkKCRldmVudClcIj5cbiAgICAgICAgICAgIDxpZ3gtaWNvbiBpZ3hQcmVmaXg+ZmlsdGVyX2xpc3Q8L2lneC1pY29uPlxuICAgICAgICAgICAge3tmaWx0ZXIubWVtYmVyTmFtZX19XG4gICAgICAgIDwvaWd4LWNoaXA+XG4gICAgPC9pZ3gtY2hpcHMtYXJlYT5cbjwvZGl2PlxuIl19